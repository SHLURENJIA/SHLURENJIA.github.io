<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[按下返回键 Activity 的生命周期变化]]></title>
    <url>%2F2017%2F05%2F31%2F%E6%8C%89%E4%B8%8B%E8%BF%94%E5%9B%9E%E9%94%AE-Activity-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Android 中的消息机制]]></title>
    <url>%2F2017%2F05%2F12%2FAndroid%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FAndroid%20%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言 涉及知识点： 消息机制：Handler、Looper 和 MessageQueue AsyncTask 基本使用 实现一个简单的 SimpleAsyncTask 消息机制Android 中的消息机制由三大部分组成：Handler、Looper 和 MessageQueue. Looper 就是创建一个 MessageQueue，然后进入一个死循环里面不断地读取 MessageQueue 里面的消息，Handler 就是消息的创建者，处理者。 由图我们可以看出，消息队列被封装在了 MessageQueue 中，通过 Looper 和线程 Thread 关联起来。而 Handler 又通过 Looper 关联，因而 Handler 最终和线程、线程的消息队列关联上来了。这也就是为什么我们常说更新 UI 的 Handler 必须要在主线程中创建，因为只有在主线程中创建，Handler 才能和主线程的消息队列关联上，这样 handleMessage 才会执行在 UI 线程，这时候更新 UI 才是线程安全的。 题外话：为什么常说只能在 UI 线程更新 UI ？ 子线程可以有好多个，但如果每个子线程都直接对UI元素进行操作，界面会混乱不堪，线程会面临安全问题，虽然可以通过加锁机制来解决线程的安全问题，但是加锁会降低运行效率， 所以主线程（UI线程）并没进行加锁限制多线程访问， 可能这就是“出于性能优化考虑”。 既然没有对多线程访问进行限制，而且子线程依然有进行UI操作的需求，那么该如何解决呢？ 所以Android规定只能在主线程中进行UI元素的更改，你们一帮菜鸡子线程如果还执意要来修改我管辖的用户界面 就必须先通知我（主线程），我来帮你们完成 :) ——知乎用户：大大大大头啊 AsyncTask 基本使用我们往往使用 Thread 创建子线程进行耗时操作，但是由于不能在子线程更新 UI，一般就会使用 Handler 发送消息给 UI 线程然后再更新。这个操作起来有点麻烦，在多个任务同时执行的时候，不易于对线程进行精细控制。于是 AsyncTask 应运而生。 123&gt; public abstract class AsyncTask&lt; Param, Progress, Result &gt; ( ) &gt; //三个泛型类型： &lt; 参数类型，后台执行任务的进度类型，返回的结果类型 &gt; 如果不需要某个类型可以设置为 void&gt; 一个异步任务一般包含以下步骤： 实现一个简单的 AsyncTask下面我们来实现一个简单的 AsyncTask，类名为 SimpleAsyncTask。与 AsyncTask 类似，提供了三个函数：onPreExecute( )、 doInBackground( )、onPostExecute( )。泛型参数为了方便只有一个 doInBackgroud( ) 函数返回值类型的泛型参数。SimpleAsyncTask 执行起来和 AsyncTask 基本一样。首先是 onPreExecute 函数在任务运行之前执行，而且运行在 UI 线程之中。doInBackgroud 运行在后台执行耗时操作，并且将结果返回。onPostExecute 含有一个参数，这个参数就是 doInBaskgroud 的返回结果，onPostExecute 执行在 UI 线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public abstract class SimpleAsyncTask&lt;Result&gt; &#123; private static final HandlerThread HT = new HandlerThread("SimpleAsyncTask", Process.THREAD_PRIORITY_BACKGROUND); static &#123; HT.start(); &#125; final Handler mUIHandler = new Handler(Looper.getMainLooper()); final Handler mAsyncHandler = new Handler(HT.getLooper()); /** * @功能描述：onPreExecute 任务执行之前的初始化操作等 */ protected void onPreExecute()&#123;&#125; /** * 后台执行任务 * @return 返回执行结果 */ protected abstract Result doInBackground(); /** * 返回结果传递给执行在 UI 线程的 onPostExecute * @param result 执行结果 */ protected void onPostExecuted(Result result)&#123; &#125; public final SimpleAsyncTask&lt;Result&gt; excute () &#123; onPreExecute(); mAsyncHandler.post(new Runnable() &#123; @Override public void run() &#123; postResult(doInBackground()); &#125; &#125;); return this; &#125; private void postResult(final Result result)&#123; mUIHandler.post(new Runnable() &#123; @Override public void run() &#123; onPostExecuted(result); &#125; &#125;); &#125;&#125; 在 SimpleAsyncTask 里面首先创建了一个 HandlerThread（自带消息队列的 Thread），当线程启动之后就会构建它的消息队列，所以构建完成后，直接在静态代码块里面启动了该线程。然后创建了两个 Handler，分别关联 UI 线程和 HandlerThread 的子线程 mAsyncHandler。剩下三个函数已经解释过了，有需要的时候我们可以重写这三个方法。 execute 是执行的函数，里面先调用 onPreExecute，然后 doInBackground 函数被一个 Runnbale 包装通过 mAsyncTask 提交给了 HandlerThread 线程执行，当得到结果的时候又通过 mUIHandler 将结果提交到一个 Runnable 里面，这个 Runnbale 中执行了 onPostExecute。 下面是调用的示例代码： 12345678910111213141516171819202122232425new SimpleAsyncTask&lt;String&gt;() &#123; private void makeToast(String msg)&#123; Toast.makeText(getApplicationContext(), msg, Toast.LENGTH_SHORT).show(); &#125; @Override protected void onPreExecute() &#123; makeToast("onPreExecute"); &#125; @Override protected String doInBackground() &#123; try&#123; Thread.sleep(6000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return "doInBackground finish!"; &#125; @Override protected void onPostExecuted(String s) &#123; makeToast("onPostExecuted"+s); &#125;&#125;.excute(); 执行结果就是先 Toast：onPreExecute，延时 6 秒之后 Toast： onPostExecuted doInBackground finish！]]></content>
      <categories>
        <category>Android 基础学习</category>
      </categories>
      <tags>
        <tag>Android 基础知识</tag>
        <tag>AsyncTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下拉刷新的实现原理（Scroller 的使用）]]></title>
    <url>%2F2017%2F05%2F12%2FAndroid%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%88Scroller%20%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 涉及知识点： Scroller 使用 自定义 ViewGroup Measure 测量 View onTouchEvent 函数 初始化视图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public abstract class RefreshLayoutBase&lt;T extends View&gt; extends ViewGroup implements AbsListView.OnScrollListener&#123; protected Scroller mScroller;//滚动控制 protected View mHeaderView; protected View mFooterView; protected T mContentView; protected int mYOffset;//本次触摸 Y 轴坐标的偏移量 protected int mInitScrollY = 0;//最初的滚动位置，第一次布局时滚动header的高度的距离 protected int mLastY = 0;//最后一次触摸 Y 轴坐标 public static final int STATUS_IDLE = 0;//空闲状态 public static final int STATUS_PULL_TO_REFRESH = 1;//下拉或者上拉，但是没有达到可以刷新的状态 public static final int STATUS_RELEASE_TO_REFRESH = 2;//下拉或者上拉状态 public static final int STATUS_REFRESHING = 3;//刷新中 public static final int STATUS_LOADING = 4;//加载中 protected int mCurrentStatus = STATUS_IDLE; private ImageView mArrowImageView;//header中的箭头图标 private boolean isArrowUp;//箭头是否向上 private TextView mTipsTextView;//header 中的文本提示 private TextView mTimeTextView;//header 中的时间提示 private ProgressBar mProgressBar;//进度条 private int mScreenHeight;//屏幕高度 private int mHeaderHeight;// Header 高度 protected OnRefreshListener mOnRefreshListener;//下拉刷新监听 protected OnLoadListener mLoadListener;//加载更多回调 public RefreshLayoutBase(Context context) &#123; this(context, null); &#125; public RefreshLayoutBase(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public RefreshLayoutBase(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs); mScroller = new Scroller(context); mScreenHeight = context.getResources().getDisplayMetrics().heightPixels;//获取屏幕高度 mHeaderHeight = mScreenHeight / 4;//header 高度为屏幕高度四分之一 initLayout(context); &#125; protected final void initLayout(Context context)&#123; //headerView setupHeaderView(context); //设置内容视图 setupContentView(context); //设置布局参数 setDefaultContentLayoutParams(); //添加 contentView 布局 addView(mContentView); //设置底部视图 setupFooterView(context); &#125; /** * 设置布局参数 * 给 ContentView 宽高设置为 match_parent */ private void setDefaultContentLayoutParams() &#123; ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT); mContentView.setLayoutParams(params); &#125; /** * 初始化 footerView * @param context */ private void setupFooterView(Context context) &#123; mFooterView = LayoutInflater.from(context).inflate(R.layout.pull_to_refresh_footer, this, false); addView(mFooterView); &#125; /** * 内容视图 */ protected abstract void setupContentView(Context context); /** * 初始化 header * @param context */ private void setupHeaderView(Context context) &#123; mHeaderView = LayoutInflater.from(context).inflate(R.layout.pull_to_refresh_header, this, false); mHeaderView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, mHeaderHeight)); mHeaderView.setBackgroundColor(Color.RED); //header 高度为屏幕 1/4，但是，他只有 100px 的有效显示区域 mHeaderView.setPadding(0, mHeaderHeight - 100, 0, 0);//左上右下 addView(mHeaderView); mArrowImageView = (ImageView) mHeaderView.findViewById(R.id.pull_to_arrow_image); mTipsTextView = (TextView) mHeaderView.findViewById(R.id.pull_to_refresh_text); mTimeTextView = (TextView) mHeaderView.findViewById(R.id.pull_to_refresh_updated_at); mProgressBar = (ProgressBar) mHeaderView.findViewById(R.id.pull_to_refresh_progress); &#125; /**if isTop return true * 达到顶部继续下拉则拦截事件 * @return */ protected abstract boolean isTop(); /** * if isBottom return true * 达到底部触发加载更多 * @return */ protected abstract boolean isBottom();/***************************************************省略部分代码，详情见github****************************************************/&#125; 首先是一大堆的变量，都加了注释也没什么说的，后面用到再说吧。这里主要是 initLayout() 初始化了整个下拉刷新的布局，从上到下 headerView、contentView、footerView。其中 header 和 footer 都是从布局中加载的，固定好了的。但是 contentView 是抽象的，可变的，我们可以设置他是 ListView，RecyclerView，GridView 等，到时候继承即可。 另外还有两个函数 isTop() 和 isBottom()，因为我们在下拉刷新和上拉加载更多的时候，不同的内容视图判断到达底部顶部的代码是不一样的，所以把它也抽象了。 测量宽高MeasureSpec 的含义，组成接下来要做的就是测量。View的测量师自定义View中最重要的一步。在贴代码之前，有几个基本概念要搞清楚。看图： UNSPECIFIED 其实是开发人员按照自己的意愿调整大小，没有任何限制。但是这种情况很少见。 EXACTLY 往往对应 match_parent, AT_MOST 往往对应 warp_content getMeasureHeight() 和 getHeight() 区别简单地说 getMeasureHeight 可以测量到屏幕以外的布局， getHeight 测量到可视布局。 举个例子，一个上拉加载更多的组件，contentView 是100dp，footerView 是 50dp，但是 footerView（加载更多视图） 不可见。用getMeasureHeight 测量的高度就是 150dp。 123456789101112131415161718192021222324252627282930313233343536373839/** * 测量 viewGroup 宽高。宽度为用户定义。高度是 header, contentView, footer 三者之和 * @param widthMeasureSpec * @param heightMeasureSpec */@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int width = MeasureSpec.getSize(widthMeasureSpec); int childCount = getChildCount();//子视图个数 int finalHeight = 0;//最终的高度 for(int i = 0; i &lt; childCount; i++)&#123; View child = getChildAt(i); measureChild(child, widthMeasureSpec, heightMeasureSpec);//测量每个子视图 finalHeight += child.getMeasuredHeight(); &#125; //设置下拉刷新组件的尺寸(也就是这个 ViewGroup ) setMeasuredDimension(width, finalHeight); super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125;/** * 将 header、content、footer 从上到下布局 * 布局完成后通过 Scroller 滚动到 header 的底部 * 滑动距离为 header 高度 + 本视图 paddingtop，达到隐藏 header */@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childCount = getChildCount(); int top = getPaddingTop(); for(int i=0; i&lt;childCount; i++) &#123; View child = getChildAt(i); child.layout(0, top, child.getMeasuredWidth(), child.getMeasuredHeight() + top); top += child.getMeasuredHeight(); &#125; mInitScrollY = mHeaderView.getMeasuredHeight() + getPaddingTop(); scrollTo(0, mInitScrollY);&#125; 在onMeasure中测量了这个组件的自身大小和子视图的大小，并在onLayout中从上到下依次布局。 在 OnLayout 的最后通过 Scroller 将该 ViewGroup 滑动了 HeaderView 的高度使其不可见。 下拉刷新当用户向下按的时候，判断 ContentView 视图滑动到了顶部。此时又通过 Scroller 将该组件向下滚动，使得 HeaderView 可见。这些功能都需要让我们处理触摸事件。 1234567891011121314151617181920212223242526272829/** * 拦截触摸事件 * 在 ContentView 滑动到顶部，并且下拉的时候拦截 */ @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; //获取触摸事件类型 final int action = MotionEventCompat.getActionMasked(ev); //取消事件或者抬起事件直接返回false if(action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP)&#123; return false; &#125; switch(action) &#123; case MotionEvent.ACTION_DOWN: mLastY = (int) ev.getRawY(); break; case MotionEvent.ACTION_MOVE: mYOffset = (int) (ev.getRawY() - mLastY); //如果拉到了顶部，并且是下拉，拦截事件，转到 onTouchEvent 处理下拉刷新 if(isTop() &amp;&amp; mYOffset &gt; 0)&#123; return true; &#125; break; default: break; &#125; return false;//false 默认不拦截 &#125; onInterceptTouchEvent 是ViewGroup 中对触摸事件进行拦截的函数，返回 true时表示拦截。 例如：如果 mYOffset &gt; 0，那么代表用户是从上往下滑动。如果此时 ContentView 已经滑动到了顶部，那么第一个可见元素就是第一项，返回 true 就是将后续的时间进行拦截。此时，后续的 ACTION_MOVE 就会转到 onTouchEvent 函数进行处理。 12345678910111213141516171819202122232425262728293031323334/** * 在这里处理下拉刷新或者上拉加载更多 * @param event * @return */@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch(event.getAction())&#123; case MotionEvent.ACTION_MOVE: int currentY = (int) event.getRawY(); mYOffset = currentY - mLastY; if(mCurrentStatus != STATUS_LOADING)&#123; changeScrollY(mYOffset); &#125; rotateHeaderArrow(); changeTips(); mLastY = currentY; break; case MotionEvent.ACTION_UP: //下拉刷新具体操作 doRefresh(); break; default: break; &#125; return true;//返回 true，消费该事件&#125;protected void doRefresh() &#123; changeHeaderViewStaus(); if(mCurrentStatus == STATUS_REFRESHING &amp;&amp; mOnRefreshListener != null)&#123; mOnRefreshListener.onRefresh(); &#125;&#125; 在 onTouchEvent 函数中，判断他的事件类型。如果还是 MOVE，就计算 y 坐标的差值，在此处调用 changeScrollY 函数，在 y 轴上滚动该控件，另外还有改变箭头方向，文字提示等。如果是 ACTION_UP 手指抬起，说明松手了，就执行下拉刷新操作。当然执行的时候要判断 y坐标下拉的偏移值够不够。 123456789101112131415161718/** * 刷新结束时候调用，视图还原为基本状态 */public void refreshComplete()&#123; mScroller.startScroll(getScrollX(),getScrollY(),0,mInitScrollY - getScrollY()); mCurrentStatus = STATUS_IDLE; invalidate(); updateHeaderTimeStamp(); //100毫秒之后处理arrow和progress，免得太突兀 this.postDelayed(new Runnable() &#123; @Override public void run() &#123; mArrowImageView.setVisibility(View.VISIBLE); mProgressBar.setVisibility(View.GONE); &#125; &#125;,100);&#125;]]></content>
      <categories>
        <category>Android 自定义控件</category>
      </categories>
      <tags>
        <tag>Android 自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android项目结构]]></title>
    <url>%2F2017%2F05%2F03%2FAndroid%20%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%2Fandroid%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[规范1.AS 规范 尽量使用最新版的IDE进行开发； 编码格式统一为UTF-8； 编辑完.java、 .xml等文件后一定要格式化（基本格式方面使用 AS 默认模板即可）； 删除多余的import，减少警告出现，可利用AS的Optimize Imports(Settings → Keymap → Optimize Imports)快捷键； 2.命名规范包名全部小写，连续的单词只是简单地连接起来，不使用下划线，采用反域名命名规则，全部使用小写字母。 一级包名是顶级域名，通常为com,edu,gov,net,org等，二级包名为公司名，三级包名根据应用进行命名，后面就是对包名的划分了，关于包名的划分，推荐使用按功能分。比如像这样： 或者参考谷歌 I/O 2015 的代码结构： 类名名词，采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的， 比如HTML, URL，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。 类 描述 例如 Activity 类 Activity为后缀标识 欢迎页面类WelcomeActivity Adapter类 Adapter 为后缀标识 新闻详情适配器 NewDetailAdapter 解析类 Parser为后缀标识 首页解析类HomePosterParser 工具方法类 Utils或Manager为后缀标识（与系统或第三方的Utils区分）或功能+Utils 线程池管理类：ThreadPoolManager日志工具类：LogUtils（Logger也可）打印工具类：PrinterUtils 数据库类 以DBHelper后缀标识 新闻数据库：NewDBHelper Service类 以Service为后缀标识 时间服务TimeService BroadcastReceiver类 以Receiver为后缀标识 推送接收JPushReceiver ContentProvider类 以Provider为后缀标识 ShareProvider 自定义的共享基础类 以Base开头 BaseActivity,BaseFragment 接口（interface）：命名规则与类一样采用大驼峰命名法，多以able或ible结尾，如： interface Runnable、interface Accessible。 注意：如果项目采用MVP，所有Model、View、Presenter的接口都以I为前缀，不加后缀，其他的接口采用上述命名规则。 方法 方法 说明 initXX() 初始化相关方法,使用init为前缀标识，如初始化布局initView() isXX() checkXX() 方法返回值为boolean型的请使用is或check为前缀标识 getXX() 返回某个值的方法，使用get为前缀标识 setXX() 设置某个属性值 handleXX()/processXX() 对数据进行处理的方法 displayXX()/showXX() 弹出提示框和提示信息，使用display/show为前缀标识 updateXX() 更新数据 saveXX() 保存数据 resetXX() 重置数据 clearXX() 清除数据 removeXX() 移除数据或者视图等，如removeView(); drawXX() 绘制数据或效果相关的，使用draw前缀标识 3.资源文件3.1.1 contentView命名必须以全部单词小写，单词间以下划线分割，使用名词或名词词组。 所有Activity或Fragment的contentView必须与其类名对应，对应规则为：将所有字母都转为小写，将类型和功能调换（也就是后缀变前缀）。 例如：activity_main.xml 3.1.5 包含项命名规则：模块_(位置)描述.xml 例如：activity_main_head.xml、activity_main_bottom.xml 注意：通用的包含项命名采用：项目名称缩写_描述.xml 例如：xxxx_title.xml 3.2 资源文件（图片drawable文件夹下）全部小写，采用下划线命名法，加前缀区分 命名模式：可加后缀 _small 表示小图， _big 表示大图，逻辑名称可由多个单词加下划线组成，采用以下规则： 用途模块名逻辑名称 用途模块名颜色 用途_逻辑名称 用途_颜色 说明：用途也指控件类型（具体见附录UI控件缩写表） http://www.jianshu.com/p/419f5357357d#ui%E6%8E%A7%E4%BB%B6%E7%BC%A9%E5%86%99%E8%A1%A8 例如： 名称 说明 btn_main_home.png 按键用途模块名逻辑名称 divider_maket_white.png 分割线用途模块名颜色 ic_edit.png 图标用途_逻辑名称 bg_main.png 背景用途_逻辑名称 btn_red.png 红色按键用途_颜色 btn_red_big.png 红色大按键用途_颜色 ic_head_small.png 小头像用途_逻辑名称 bg_input.png 输入框背景用途_逻辑名称 divider_white.png 白色分割线用途_颜色 bg_main_head 主模块头部背景图片用途模块名逻辑名称 def_search_cell 默认搜索界面单元图片用途模块名逻辑名称 ic_more_help 更多帮助图标用途_逻辑名称 divider_list_line 列表分割线用途_逻辑名称 selector_search_ok 搜索界面确认选择器用途模块名逻辑名称 shape_music_ring 音乐界面环形形状用途模块名逻辑名称 如果有多种形态，如按钮选择器：btn_xx.xml(selector) 名称 说明 btn_xx 按钮图片使用btn_整体效果（selector） btn_xx_normal 按钮图片使用btn_正常情况效果 btn_xx_pressed 按钮图片使用btn_点击时候效果 btn_xx_focused state_focused聚焦效果 btn_xx_disabled state_enabled (false)不可用效果 btn_xx_checked state_checked选中效果 btn_xx_selected state_selected选中效果 btn_xx_hovered state_hovered悬停效果 btn_xx_checkable state_checkable可选效果 btn_xx_activated state_activated激活的 btn_xx_windowfocused state_window_focused 注意：使用AndroidStudio的插件SelectorChapek可以快速生成selector，前提是命名要规范。 3.3 动画文件（anim文件夹下）全部小写，采用下划线命名法，加前缀区分。 具体动画采用以下规则：模块名_逻辑名称。 例如：refresh_progress.xml、market_cart_add.xml、market_cart_remove.xml。 普通的tween动画采用如下表格中的命名方式：动画类型_方向 名称 说明 fade_in 淡入 fade_out 淡出 push_down_in 从下方推入 push_down_out 从下方推出 push_left 推向左方 slide_in_from_top 从头部滑动进入 zoom_enter 变形进入 slide_in 滑动进入 shrink_to_middle 中间缩小]]></content>
      <categories>
        <category>Android 项目基础</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>规范</tag>
      </tags>
  </entry>
</search>