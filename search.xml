<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 动画总结]]></title>
    <url>%2F2017%2F06%2F05%2FAndroid%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FAndroid%20%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Android 里面的动画可以分为两类，传统动画 和 3.0 以后出现的属性动画。 传统动画又分为两种：帧动画（Frame Animation）和补间动画（Tweened Animation） 传统动画帧动画（Frame Animation）帧动画就是像 GIF 的动图，一定时间内多张图片切换达到动画的视觉效果。 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/a_0" android:duration="100" /&gt; &lt;item android:drawable="@drawable/a_1" android:duration="100" /&gt; &lt;item android:drawable="@drawable/a_2" android:duration="100" /&gt;&lt;/animation-list&gt; 12345678protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_frame_animation); ImageView animationImg1 = (ImageView) findViewById(R.id.animation1); animationImg1.setImageResource(R.drawable.frame_anim1); AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable(); animationDrawable1.start(); &#125; 图片资源决定了这个动画，一定程度上也会因此占了资源的使用。 另外，有个常用的属性： android : oneshot=”false” ，就是只循环一次。 补间动画（Tweened Animation ）补间动画有四种属性： alpha：淡入淡出，透明度 translate：位移 scale：缩放大小 rotate： 旋转 补间动画一般使用 xml 来实现。举例子： alpha_anim.xml 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;alpha xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000" android:fromAlpha="1.0" android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:toAlpha="0.0" /&gt; scale.xm 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000" android:fromXScale="0.0" android:fromYScale="0.0" android:pivotX="50%" android:pivotY="50%" android:toXScale="1.0" android:toYScale="1.0"/&gt; Activity 中 123Animation animation = AnimationUtils.loadAnimation(mContext, R.anim.alpha_anim);img = (ImageView) findViewById(R.id.img);img.startAnimation(animation); 更多的时候，我们会将四个属性用 set 标签结合起来使用。 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:interpolator="@[package:]anim/interpolator_resource" android:shareInterpolator=["true" | "false"] &gt; &lt;alpha android:fromAlpha="float" android:toAlpha="float" /&gt; &lt;scale android:fromXScale="float" android:toXScale="float" android:fromYScale="float" android:toYScale="float" android:pivotX="float" android:pivotY="float" /&gt; &lt;translate android:fromXDelta="float" android:toXDelta="float" android:fromYDelta="float" android:toYDelta="float" /&gt; &lt;rotate android:fromDegrees="float" android:toDegrees="float" android:pivotX="float" android:pivotY="float" /&gt; &lt;set&gt; ... &lt;/set&gt;&lt;/set&gt; 其中稍稍一提的是 Interpolator ：主要是调变化的速率的。里面的属性有 AccelerateDecelerateInterpolator 在动画开始与介绍的地方速率改变比较慢，在中间的时候加速 AccelerateInterpolator 在动画开始的地方速率改变比较慢，然后开始加速 AnticipateInterpolator 开始的时候向后然后向前甩 AnticipateOvershootInterpolator 开始的时候向后然后向前甩一定值后返回最后的值 BounceInterpolator 动画结束的时候弹起 CycleInterpolator 动画循环播放特定的次数，速率改变沿着正弦曲线 DecelerateInterpolator 在动画开始的地方快然后慢 LinearInterpolator 以常量速率改变 OvershootInterpolator 向前甩一定值后再回到原来位置 像这样：android:interpolator=”@android:anim/accelerate_decelerate_interpolator” pivot: 决定了当前动画执行的参考位置 pivotX取值 含义 10 距离动画所在view自身左边缘10像素 10% 距离动画所在view自身左边缘 的距离是整个view宽度的10% 10%p 距离动画所在view父控件左边缘的距离是整个view宽度的10% 类同 pivotY 属性动画属性动画，是针对于对象属性的动画，补间动画的四个属性也在其中，因此，所有补间动画的内容都可以通过属性动画实现。 属性动画达到补间动画效果12345678910111213private void RotateAnimation() &#123; ObjectAnimator anim = ObjectAnimator.ofFloat(myView, "rotation", 0f, 360f); anim.setDuration(1000); anim.start(); &#125; private void AlpahAnimation() &#123; ObjectAnimator anim = ObjectAnimator.ofFloat(myView, "alpha", 1.0f, 0.8f, 0.6f, 0.4f, 0.2f, 0.0f); anim.setRepeatCount(-1);//重复执行次数。设置n，执行n+1次 anim.setRepeatMode(ObjectAnimator.REVERSE);//重复模式，重新从头执行。 anim.setDuration(2000); anim.start(); &#125; 如果是多组合的属性，也可以通过代码实现 1234567891011 ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(myView, "alpha", 1.0f, 0.5f, 0.8f, 1.0f); ObjectAnimator scaleXAnim = ObjectAnimator.ofFloat(myView, "scaleX", 0.0f, 1.0f); ObjectAnimator scaleYAnim = ObjectAnimator.ofFloat(myView, "scaleY", 0.0f, 2.0f); ObjectAnimator rotateAnim = ObjectAnimator.ofFloat(myView, "rotation", 0, 360); ObjectAnimator transXAnim = ObjectAnimator.ofFloat(myView, "translationX", 100, 400); ObjectAnimator transYAnim = ObjectAnimator.ofFloat(myView, "tranlsationY", 100, 750); AnimatorSet set = new AnimatorSet(); set.playTogether(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);//同时播放// set.playSequentially(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);//按顺序播放 set.setDuration(3000); set.start(); 上面使用的都是 ObjectAnimator ，他继承自 ValueAnimator ，而 valueAnimator 是整个属性动画机制最核心的类。 属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。 —— Android SDK API 文档 上图中我们可以看出可以通过 duration, startPropertyValue, endPropertyValue 等值，设置动画时长，初始值和结束值，然后通过 start（） 方法开启动画。 那么， TimeInterpolator 和 TypeEvaluator 又是干什么的呢？ TypeEvaluator ，意思为类型估值器。可以说是用来确定轨迹变化的。它的作用就是根据当前动画已经执行的时间占总时间的百分比来计算新的属性值。他只有一个函数，evaluate( float fraction, T startValue, T endValue ) 其中第一个参数为已执行时间占总时间的百分比。取值为[ 0.0 - 1.0 ].这个效果出来是线性的。比如平移，移动的速率是不变的。但是我们有时候需要非线性的效果，比如，小球模拟重力效果下坠之类。那就要 TimeInterPolator TimeInterpolator ，翻译的话是时间插值器。他就是通过 getInterpolator( float input ) 来改变上面的 fraction .重写这个函数里面对 input 进行一些换算（比如 input * input）,这样动画就会越来越快。]]></content>
      <categories>
        <category>Android 基础学习</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Broadcast Receiver 相关]]></title>
    <url>%2F2017%2F06%2F04%2FAndroid%20%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Broadcast%20Receiver%20%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[广播的常用场景开机启动服务，网络状态改变，电量变化，短信和来电通知通过接受系统的广播让应用程序做出相应处理。 使用注意系统或者应用发出广播的时候，将会扫描系统中所有的广播接收者，通过 action 匹配将广播发送给相应的接收者。收到广播后将会产生一个广播接收者的实例。执行 onReceiver() 这个方法。但是！这个实例的生命周期只有十秒。十秒内没有结束将会报错（ANR：Application Not Responding） 所以不要在 onReceiver() 中执行耗时操作，也不要在里面创建子线程处理业务（业务没处理完接收者就被回收了，子线程也会被回收掉）。 正确的应该是通过 in 调用 antivity 或者 service 处理业务。 广播的动态注册和静态注册有什么区别 静态注册，在 Manifest 文件里面进行注册，程序退出以后，Receiver 仍然可以接受到广播并且进行相应处理。 动态注册，在代码里面注册（onResume() 注册, onPause() 卸载），app 退出以后就无法再接受广播了。 发送广播的两种类型普通广播应用在需要通知各个广播接收者的情况下使用。比如开机。 sendBroadcast() 123Intent intent = new Intent("android.provider.Telephony.SMS_RECEIVER");intent.putExtra("data", "finch");//少量数据sendBroadcast(intent); 异步，消息传递效率较高，但是无法中断广播的传播。 有序广播广播会优先发给优先级 (android:priority) 高的 Receiver。并且能决定是否终止广播的继续传播。 特定拦截情境下使用。比如，黑名单短信，电话拦截。 sendOrderedBroadReceiver(intent, receiverPermission); 12345678910public void onReceiver(Context context, Intent intent)&#123; //获取上一个广播的bundle数据 Bundle bundle = getResultExtras(true);//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle bundle.putString("key", "777"); //将bundle数据放入广播中传给下一个广播接收者 setResultExtras(bundle); //终止广播传给下一个广播接收者 abortBroadcast();&#125; LocalBroadcastManager有时候基于数据安全考虑，我们想发送广播只有自己（本进程）能接收到，那么该如何去做呢？ 这就要提到 localBroadcastManager 了。 发送的广播只在自己 app 内传播，不会泄露发给其他 app，确保隐私数据不会泄露 比系统全局广播更加高效 和系统广播使用方式类似： 先通过LocalBroadcastManager lbm = LocalBroadcastManager.getInstance(this); 获取实例 然后通过函数 registerReceiver来注册监听器 12345678lbm.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO Handle the received local broadcast &#125; &#125;, new IntentFilter(LOCAL_ACTION)); lbm.sendBroadcast(new Intent(LOCAL_ACTION)); 使用广播来更新界面是否合适如果是比较频繁地更新界面，还是不要用广播了。 广播也会有延时的情况。sendBroadcast 之后，广播被 activityManagerService 放入队列，但并不会马上处理。 当处理到当前广播的时候，又会把这个广播分发给 ReceiverDispatcher 广播接受分发器，然后再把广播分发给 Receiver 所在的线程消息队列去处理。（UI 线程的 MessageQueue）。 整个过程从发送——ActivityManagerReceiver——ReceiverDispatcher 进行了两次 Binder 进程间通信，最后还要交到UI的消息队列，如果其中·有一个的消息的处理阻塞了UI，就会延迟 onReceiver 的执行。]]></content>
      <categories>
        <category>Android 面试集锦</category>
      </categories>
      <tags>
        <tag>四大组件</tag>
        <tag>面试</tag>
        <tag>Boradcast Reveiver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service 相关]]></title>
    <url>%2F2017%2F06%2F04%2FAndroid%20%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Service%20%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Service 的生命周期 onCreate 里面可以做耗时操作吗？不可以。service 也是在主线程里面运行的。耗时操作会阻塞UI。 如果需要耗时操作，你会怎么做？ service 中启动子线程处理。或者使用 IntentService ； Service 的两种启动方法有何区别 在 Context 中通过 public boolean bindService(Intent service, ServiceConnection conn, int flags) 方法来进行 Service 与 Context 的关联并启动， Service 的生命周期依附于 Context （不求同生，但是同死）,当启动方法销毁的时候会自动 unBind ,当发现所有的绑定都进行解绑之后才会销毁 Service。 通过 public ComponentName startService(Intent service) 方法启动一个 Service，生命周期与 Context 无关。只有当调用 stopSelf 或者其他组件调用 stopService 服务才会停止。 如何保证 Sercive 不被杀死首先完全不被杀死是不可能的，除非是系统级别的。能做的是杀死后采取措施让 Service 重新启动。 1. Service 设置成 START_STICKY kill 之后会被重启（等待时间 5秒 ），重传 Intent，保持与重启之前一样。 1234567&gt; @Override&gt; public int onStartCommand(Intent intent, int flags, int startId) &#123;&gt; flags = START_STICKY;&gt; return super.onStartCommand(intent, flags, startId);&gt; // return START_REDELIVER_INTENT;&gt; &#125;&gt; &gt; ​ 2. 提升 Service 优先级 在 Manifest 文件中对 intent-filter 设置属性 android:priority = &quot;1000&quot; ，其中，1000 是最高的优先级，数值越小优先级越低。（同样适用于广播） 【结论】目前看来，priority这个属性貌似只适用于broadcast，对于Service来说可能无效。 3. 提升 Service 进程优先级 Android 中进程是托管的，当系统进程空间紧张的时候，会依照优先级自动对进程回收。先销毁优先级低的。 前台进程 &gt; 可见进程 &gt; 服务进程 &gt; 后台进程 &gt; 内容供应节点(CONTENT_PROVIDER) &gt; 空进程 使用 startForeground 将 Service 放到前台状态 在极度低内存的情况下还是会 kill 掉，并且一定不会 restart 。 4. onDestory 方法里面重启 Service service + broadcast 方式，就是当 Service 走 onDestory 的时候，发送一条自定义广播，当收到广播时，重启 Service。 也可以直接在 onDestory 里面 startService 。 123456&gt; public void onDestroy() &#123; &gt; Intent localIntent = new Intent();&gt; localIntent.setClass(this, MyService.class); //销毁时重新启动Service&gt; this.startService(localIntent);&gt; &#125;&gt; &gt; ​ 在 setting 里面强制停止的话，app 进程就可能直接被干掉了，onDestory 都进不来。 5. 据说 手机QQ 放了一个像素在前台，顽强过小强。 IntentService 的使用场景与特点 IntentService 是 Service 的子类，是一个异步的，会自动停止的服务。很好滴解决了传统 Service 中处理完耗时操作之后忘记销毁 Service 的问题。内部还是用 handler 实现的。 优点： 不需要自己去 new Thread 不需要考虑什么时候关闭该 Service 使用场景：（！！！这里没懂，待验证！！！） onStartCommand中回调了onStart，onStart中通过mServiceHandler发送消息到该handler的handleMessage中去。最后handleMessage中回调onHandleIntent(intent)。]]></content>
      <categories>
        <category>Android 面试集锦</category>
      </categories>
      <tags>
        <tag>四大组件</tag>
        <tag>面试</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity 相关]]></title>
    <url>%2F2017%2F06%2F04%2FAndroid%20%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Activity%20%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Activity 基础Activity 是 Android 的四大组件之一。我们在使用的时候，往往都要在 Manifest 文件中给活动进行注册。 123456789&lt;activity android:name=".MainActivity" android:launchMode="singleTask"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;activity android:name=".SecondActivity"&gt;&lt;/activity&gt;&lt;acyivity android:name=".xxx"&gt;&lt;/activity&gt; 每个 Activity 都会存放到一个栈中（back stack），所有的 Activity 归属于栈管理。一般来说我们只有一个返回栈装载 Activity，每次启动新活动的时候都在栈顶新建一个Activity的实例并压入栈底。这也就是Activity启动的标准模式 (Standard). Activity 的启动模式可以在上面 Manifest 文件声明 Activity 那里看见，声明 Activity 的启动模式是 android:launchMode, android:launchMode = “standard | singleTop | singletTask | singleInstance” Standard 标准模式，也是默认的启动模式。假如有两个 Activity A，B。在标准模式情况下，先新建了 Activity A，A 入栈，点击跳转到 Activity B，新建 B 实例，压栈，然后 B 跳转到 A，A创建实例压栈。这样返回栈从底向上为 A1、B、A2. 不管这个 Activity 是否已经存在，Activity 的三回调都会执行（onCreate-&gt;onStart-&gt;onResume） SingleTop 栈顶模式，栈顶复用 。字面理解，就是在标准模式的情况下，如果新建的 Activity A 已经是栈顶，那么 A 将不会被创建，三回调不执行，同时 Activity 的 onNewIntent( )会被回调。 如果新的 Activity 不是栈顶，那么作用和 Standard 模式一样。 SingleTask 单栈模式，栈内复用 。创建 Activity 的时候，系统会判定栈内是否存在该 Activity 的实例，如果没有，创建实例压栈。 如果有，且在栈顶，不创建实例，直接复用。 如果有但是不在栈顶，会将该 Activity 上面的栈全部弹栈出去，让这个 Activity 调到了栈顶。 SingleInstance 单例模式。这里说的单例是全局单例。无论哪个 Task 中启动目标 Activity ，都只会创建一个 Activity 实例并却会用一个全新的栈来装载他。 ​ Activity 的生命周期Activity 最重要就是掌握生命周期。解释之前，先贴图： 这是经典的官方 Activity 生命周期图表。对于生命周期，我们一般分为一下几个周期： activity的完整生存期会在 onCreate() 调用和 onDestroy() 调用之间发生。 activity的可见生存期会在 onStart() 调用和 onStop() 调用之间发生。系统会在activity的整个生存期内多次调用 onStart() 和onStop()， 因为activity可能会在显示和隐藏之间不断地来回切换。 activity的前后台切换会在 onResume() 调用和 onPause() 之间发生。因为这个状态可能会经常发生转换，为了避免切换迟缓引起的用户等待，这两个方法中的代码应该相当地轻量化。 另外还有几个常见的我们会接触到的应用场景的周期： 启动 Activity:onCreate()—&gt;onStart()—&gt;onResume()，Activity 进入运行状态。 Activity 退居后台:当前Activity转到新的 Activity 界面或按 Home 键 回到主屏：onPause()—&gt;onStop()，进入停滞状态。 Activity 返回前台:onRestart()—&gt;onStart()—&gt;onResume()，再次回到运行状态。 Activity退居后台，且系统内存不足，系统会杀死这个后台状态的Activity（此时这个Activity引用仍然处在任务栈中，只是这个时候引用指向的对象已经为null），若再次回到这个Activity,则会走onCreate()–&gt;onStart()—&gt;onResume()(将重新走一次Activity的初始化生命周期) 锁屏：onPause()-&gt;onStop() 解锁：onStart()-&gt;onResume() ​ 几个问题1. Activity A 跳转到 Activity B 后按下返回键 A 的生命周期变化2.Activity 的缓存方法 有两个 Activity a,b ，当从 A 进入 B 一段时间时候，可能会把 A 回收，这时候按下返回键，执行的就不是 Acticity 的 onRestart( )方法，而是 onCreate( )，A 被重新创建了一次，这时，A 中保存的临时数据和状态可能就丢失了。 这就是我们为什么要对 Activity 进行缓存。 onSaveInstanceState( Bundle bundle)这个方法会在 Activity 变得“容易”被销毁前调用，方法中一个 Bundle 参数可以存储键值对。以便回收后重建时数据恢复（ onCreate 或者 onRestoreInstanceState 里面恢复）。 先看一下一般的使用： 12345678910111213141516171819202122232425 @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //这里，当Acivity第一次被创建的时候为空 //所以我们需要判断一下 if( savedInstanceState != null )&#123; savedInstanceState.getString("key"); &#125;&#125;@Overrideprotected void onSaveInstanceState(Bundle outState)&#123; super.onSaveInstanceState(outState); outState.putString("key","Android");&#125; @Overrideprotected void onRestoreInstanceState(Bundle savedInstanceState) &#123; if(savedInstanceState!=null)&#123; //判断是否有以前的保存状态信息 savedInstanceState.get("Key"); &#125; super.onRestoreInstanceState(savedInstanceState);&#125; 上面我们有提到“容易”这个词，意思是当 Activity 还没有被销毁，但是有可能被销毁，存在可能性。换而言之，就是未经你允许时销毁了你的活动，那么系统救调用 onSaveInstanceState。 那么可能性有哪些？ 按下 HOME 键。 长按 HOME 键。（切换应用） 按下电源键。（熄屏） 从 Acitivty A 中启动一个新的 Activity。 切换屏幕方向。（不指定 configchange 属性） 注意： 不要在 onSaveInstanceState 里面去存储持久化数据。因为它本身带有不确定性，这个方法应该记录 Activity 的瞬间状态（UI状态）。当用户离开这个 Activity 应该在 onPause 里面存储持久化数据，例如存入数据库。 onSaveInstanceState 如果被调用一定会在 onStop 前被调用，但是不能保证它在 onPause 前还是后调用。]]></content>
      <categories>
        <category>Android 面试集锦</category>
      </categories>
      <tags>
        <tag>Activity</tag>
        <tag>四大组件</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[按下返回键 Activity 的生命周期变化]]></title>
    <url>%2F2017%2F05%2F31%2FAndroid%20%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F%E6%8C%89%E4%B8%8B%E8%BF%94%E5%9B%9E%E9%94%AE-Activity-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言： 因为之前被大佬问道这个问题，回来记录一下： 两个活动，从 Activity A 跳转到 Activity B 之后，按下返回键，Activity A 的生命周期变化？ 明显，这是一个生命周期问题。我回来之后，先创建了两个 Activity，并且重写了包括 onRestart（）方法在内的生命周期的方法，用 Log 打印输出。最后结果如下： 明显可见，Activity A 创建完毕（ onResume ）后，点击跳转，Activity A 就进入 onPause 状态，这时候就是 Activity B开始创建了，当 Activity B 创建完毕可见（ onResume ）后，Activity A 进入 onStop 状态。此时 A 不可见，B 可见。 点击返回键之后，B 进入 onPause 状态，而 A 调用 onStart 方法，走正常的周期流程。而 B 就进入销毁的程序。 过程如下： onCreate(A) -&gt; onStart(A) -&gt; onResume(A) -&gt; 点击跳转到 B -&gt; onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A) -&gt; 按下返回键 -&gt; onPause(B) -&gt; onRestart(A) -&gt; onStart(A) -&gt; onResume(A) -&gt; onStop(B) -&gt; onDestroy(B)]]></content>
      <categories>
        <category>Android 问题记录</category>
      </categories>
      <tags>
        <tag>Activity</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中的消息机制]]></title>
    <url>%2F2017%2F05%2F12%2FAndroid%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FAndroid%20%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言 涉及知识点： 消息机制：Handler、Looper 和 MessageQueue AsyncTask 基本使用 实现一个简单的 SimpleAsyncTask 消息机制Android 中的消息机制由三大部分组成：Handler、Looper 和 MessageQueue. Looper 就是创建一个 MessageQueue，然后进入一个死循环里面不断地读取 MessageQueue 里面的消息，Handler 就是消息的创建者，处理者。 由图我们可以看出，消息队列被封装在了 MessageQueue 中，通过 Looper 和线程 Thread 关联起来。而 Handler 又通过 Looper 关联，因而 Handler 最终和线程、线程的消息队列关联上来了。这也就是为什么我们常说更新 UI 的 Handler 必须要在主线程中创建，因为只有在主线程中创建，Handler 才能和主线程的消息队列关联上，这样 handleMessage 才会执行在 UI 线程，这时候更新 UI 才是线程安全的。 题外话：为什么常说只能在 UI 线程更新 UI ？ 子线程可以有好多个，但如果每个子线程都直接对UI元素进行操作，界面会混乱不堪，线程会面临安全问题，虽然可以通过加锁机制来解决线程的安全问题，但是加锁会降低运行效率， 所以主线程（UI线程）并没进行加锁限制多线程访问， 可能这就是“出于性能优化考虑”。 既然没有对多线程访问进行限制，而且子线程依然有进行UI操作的需求，那么该如何解决呢？ 所以Android规定只能在主线程中进行UI元素的更改，你们一帮菜鸡子线程如果还执意要来修改我管辖的用户界面 就必须先通知我（主线程），我来帮你们完成 :) ——知乎用户：大大大大头啊 AsyncTask 基本使用我们往往使用 Thread 创建子线程进行耗时操作，但是由于不能在子线程更新 UI，一般就会使用 Handler 发送消息给 UI 线程然后再更新。这个操作起来有点麻烦，在多个任务同时执行的时候，不易于对线程进行精细控制。于是 AsyncTask 应运而生。 123&gt; public abstract class AsyncTask&lt; Param, Progress, Result &gt; ( ) &gt; //三个泛型类型： &lt; 参数类型，后台执行任务的进度类型，返回的结果类型 &gt; 如果不需要某个类型可以设置为 void&gt; 一个异步任务一般包含以下步骤： 实现一个简单的 AsyncTask下面我们来实现一个简单的 AsyncTask，类名为 SimpleAsyncTask。与 AsyncTask 类似，提供了三个函数：onPreExecute( )、 doInBackground( )、onPostExecute( )。泛型参数为了方便只有一个 doInBackgroud( ) 函数返回值类型的泛型参数。SimpleAsyncTask 执行起来和 AsyncTask 基本一样。首先是 onPreExecute 函数在任务运行之前执行，而且运行在 UI 线程之中。doInBackgroud 运行在后台执行耗时操作，并且将结果返回。onPostExecute 含有一个参数，这个参数就是 doInBaskgroud 的返回结果，onPostExecute 执行在 UI 线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public abstract class SimpleAsyncTask&lt;Result&gt; &#123; private static final HandlerThread HT = new HandlerThread("SimpleAsyncTask", Process.THREAD_PRIORITY_BACKGROUND); static &#123; HT.start(); &#125; final Handler mUIHandler = new Handler(Looper.getMainLooper()); final Handler mAsyncHandler = new Handler(HT.getLooper()); /** * @功能描述：onPreExecute 任务执行之前的初始化操作等 */ protected void onPreExecute()&#123;&#125; /** * 后台执行任务 * @return 返回执行结果 */ protected abstract Result doInBackground(); /** * 返回结果传递给执行在 UI 线程的 onPostExecute * @param result 执行结果 */ protected void onPostExecuted(Result result)&#123; &#125; public final SimpleAsyncTask&lt;Result&gt; excute () &#123; onPreExecute(); mAsyncHandler.post(new Runnable() &#123; @Override public void run() &#123; postResult(doInBackground()); &#125; &#125;); return this; &#125; private void postResult(final Result result)&#123; mUIHandler.post(new Runnable() &#123; @Override public void run() &#123; onPostExecuted(result); &#125; &#125;); &#125;&#125; 在 SimpleAsyncTask 里面首先创建了一个 HandlerThread（自带消息队列的 Thread），当线程启动之后就会构建它的消息队列，所以构建完成后，直接在静态代码块里面启动了该线程。然后创建了两个 Handler，分别关联 UI 线程和 HandlerThread 的子线程 mAsyncHandler。剩下三个函数已经解释过了，有需要的时候我们可以重写这三个方法。 execute 是执行的函数，里面先调用 onPreExecute，然后 doInBackground 函数被一个 Runnbale 包装通过 mAsyncTask 提交给了 HandlerThread 线程执行，当得到结果的时候又通过 mUIHandler 将结果提交到一个 Runnable 里面，这个 Runnbale 中执行了 onPostExecute。 下面是调用的示例代码： 12345678910111213141516171819202122232425new SimpleAsyncTask&lt;String&gt;() &#123; private void makeToast(String msg)&#123; Toast.makeText(getApplicationContext(), msg, Toast.LENGTH_SHORT).show(); &#125; @Override protected void onPreExecute() &#123; makeToast("onPreExecute"); &#125; @Override protected String doInBackground() &#123; try&#123; Thread.sleep(6000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return "doInBackground finish!"; &#125; @Override protected void onPostExecuted(String s) &#123; makeToast("onPostExecuted"+s); &#125;&#125;.excute(); 执行结果就是先 Toast：onPreExecute，延时 6 秒之后 Toast： onPostExecuted doInBackground finish！]]></content>
      <categories>
        <category>Android 基础学习</category>
      </categories>
      <tags>
        <tag>Android 基础知识</tag>
        <tag>AsyncTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下拉刷新的实现原理（Scroller 的使用）]]></title>
    <url>%2F2017%2F05%2F12%2FAndroid%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%88Scroller%20%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 涉及知识点： Scroller 使用 自定义 ViewGroup Measure 测量 View onTouchEvent 函数 初始化视图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public abstract class RefreshLayoutBase&lt;T extends View&gt; extends ViewGroup implements AbsListView.OnScrollListener&#123; protected Scroller mScroller;//滚动控制 protected View mHeaderView; protected View mFooterView; protected T mContentView; protected int mYOffset;//本次触摸 Y 轴坐标的偏移量 protected int mInitScrollY = 0;//最初的滚动位置，第一次布局时滚动header的高度的距离 protected int mLastY = 0;//最后一次触摸 Y 轴坐标 public static final int STATUS_IDLE = 0;//空闲状态 public static final int STATUS_PULL_TO_REFRESH = 1;//下拉或者上拉，但是没有达到可以刷新的状态 public static final int STATUS_RELEASE_TO_REFRESH = 2;//下拉或者上拉状态 public static final int STATUS_REFRESHING = 3;//刷新中 public static final int STATUS_LOADING = 4;//加载中 protected int mCurrentStatus = STATUS_IDLE; private ImageView mArrowImageView;//header中的箭头图标 private boolean isArrowUp;//箭头是否向上 private TextView mTipsTextView;//header 中的文本提示 private TextView mTimeTextView;//header 中的时间提示 private ProgressBar mProgressBar;//进度条 private int mScreenHeight;//屏幕高度 private int mHeaderHeight;// Header 高度 protected OnRefreshListener mOnRefreshListener;//下拉刷新监听 protected OnLoadListener mLoadListener;//加载更多回调 public RefreshLayoutBase(Context context) &#123; this(context, null); &#125; public RefreshLayoutBase(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public RefreshLayoutBase(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs); mScroller = new Scroller(context); mScreenHeight = context.getResources().getDisplayMetrics().heightPixels;//获取屏幕高度 mHeaderHeight = mScreenHeight / 4;//header 高度为屏幕高度四分之一 initLayout(context); &#125; protected final void initLayout(Context context)&#123; //headerView setupHeaderView(context); //设置内容视图 setupContentView(context); //设置布局参数 setDefaultContentLayoutParams(); //添加 contentView 布局 addView(mContentView); //设置底部视图 setupFooterView(context); &#125; /** * 设置布局参数 * 给 ContentView 宽高设置为 match_parent */ private void setDefaultContentLayoutParams() &#123; ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT); mContentView.setLayoutParams(params); &#125; /** * 初始化 footerView * @param context */ private void setupFooterView(Context context) &#123; mFooterView = LayoutInflater.from(context).inflate(R.layout.pull_to_refresh_footer, this, false); addView(mFooterView); &#125; /** * 内容视图 */ protected abstract void setupContentView(Context context); /** * 初始化 header * @param context */ private void setupHeaderView(Context context) &#123; mHeaderView = LayoutInflater.from(context).inflate(R.layout.pull_to_refresh_header, this, false); mHeaderView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, mHeaderHeight)); mHeaderView.setBackgroundColor(Color.RED); //header 高度为屏幕 1/4，但是，他只有 100px 的有效显示区域 mHeaderView.setPadding(0, mHeaderHeight - 100, 0, 0);//左上右下 addView(mHeaderView); mArrowImageView = (ImageView) mHeaderView.findViewById(R.id.pull_to_arrow_image); mTipsTextView = (TextView) mHeaderView.findViewById(R.id.pull_to_refresh_text); mTimeTextView = (TextView) mHeaderView.findViewById(R.id.pull_to_refresh_updated_at); mProgressBar = (ProgressBar) mHeaderView.findViewById(R.id.pull_to_refresh_progress); &#125; /**if isTop return true * 达到顶部继续下拉则拦截事件 * @return */ protected abstract boolean isTop(); /** * if isBottom return true * 达到底部触发加载更多 * @return */ protected abstract boolean isBottom();/***************************************************省略部分代码，详情见github****************************************************/&#125; 首先是一大堆的变量，都加了注释也没什么说的，后面用到再说吧。这里主要是 initLayout() 初始化了整个下拉刷新的布局，从上到下 headerView、contentView、footerView。其中 header 和 footer 都是从布局中加载的，固定好了的。但是 contentView 是抽象的，可变的，我们可以设置他是 ListView，RecyclerView，GridView 等，到时候继承即可。 另外还有两个函数 isTop() 和 isBottom()，因为我们在下拉刷新和上拉加载更多的时候，不同的内容视图判断到达底部顶部的代码是不一样的，所以把它也抽象了。 测量宽高MeasureSpec 的含义，组成接下来要做的就是测量。View的测量师自定义View中最重要的一步。在贴代码之前，有几个基本概念要搞清楚。看图： UNSPECIFIED 其实是开发人员按照自己的意愿调整大小，没有任何限制。但是这种情况很少见。 EXACTLY 往往对应 match_parent, AT_MOST 往往对应 warp_content getMeasureHeight() 和 getHeight() 区别简单地说 getMeasureHeight 可以测量到屏幕以外的布局， getHeight 测量到可视布局。 举个例子，一个上拉加载更多的组件，contentView 是100dp，footerView 是 50dp，但是 footerView（加载更多视图） 不可见。用getMeasureHeight 测量的高度就是 150dp。 123456789101112131415161718192021222324252627282930313233343536373839/** * 测量 viewGroup 宽高。宽度为用户定义。高度是 header, contentView, footer 三者之和 * @param widthMeasureSpec * @param heightMeasureSpec */@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int width = MeasureSpec.getSize(widthMeasureSpec); int childCount = getChildCount();//子视图个数 int finalHeight = 0;//最终的高度 for(int i = 0; i &lt; childCount; i++)&#123; View child = getChildAt(i); measureChild(child, widthMeasureSpec, heightMeasureSpec);//测量每个子视图 finalHeight += child.getMeasuredHeight(); &#125; //设置下拉刷新组件的尺寸(也就是这个 ViewGroup ) setMeasuredDimension(width, finalHeight); super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125;/** * 将 header、content、footer 从上到下布局 * 布局完成后通过 Scroller 滚动到 header 的底部 * 滑动距离为 header 高度 + 本视图 paddingtop，达到隐藏 header */@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childCount = getChildCount(); int top = getPaddingTop(); for(int i=0; i&lt;childCount; i++) &#123; View child = getChildAt(i); child.layout(0, top, child.getMeasuredWidth(), child.getMeasuredHeight() + top); top += child.getMeasuredHeight(); &#125; mInitScrollY = mHeaderView.getMeasuredHeight() + getPaddingTop(); scrollTo(0, mInitScrollY);&#125; 在onMeasure中测量了这个组件的自身大小和子视图的大小，并在onLayout中从上到下依次布局。 在 OnLayout 的最后通过 Scroller 将该 ViewGroup 滑动了 HeaderView 的高度使其不可见。 下拉刷新当用户向下按的时候，判断 ContentView 视图滑动到了顶部。此时又通过 Scroller 将该组件向下滚动，使得 HeaderView 可见。这些功能都需要让我们处理触摸事件。 1234567891011121314151617181920212223242526272829/** * 拦截触摸事件 * 在 ContentView 滑动到顶部，并且下拉的时候拦截 */ @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; //获取触摸事件类型 final int action = MotionEventCompat.getActionMasked(ev); //取消事件或者抬起事件直接返回false if(action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP)&#123; return false; &#125; switch(action) &#123; case MotionEvent.ACTION_DOWN: mLastY = (int) ev.getRawY(); break; case MotionEvent.ACTION_MOVE: mYOffset = (int) (ev.getRawY() - mLastY); //如果拉到了顶部，并且是下拉，拦截事件，转到 onTouchEvent 处理下拉刷新 if(isTop() &amp;&amp; mYOffset &gt; 0)&#123; return true; &#125; break; default: break; &#125; return false;//false 默认不拦截 &#125; onInterceptTouchEvent 是ViewGroup 中对触摸事件进行拦截的函数，返回 true时表示拦截。 例如：如果 mYOffset &gt; 0，那么代表用户是从上往下滑动。如果此时 ContentView 已经滑动到了顶部，那么第一个可见元素就是第一项，返回 true 就是将后续的时间进行拦截。此时，后续的 ACTION_MOVE 就会转到 onTouchEvent 函数进行处理。 12345678910111213141516171819202122232425262728293031323334/** * 在这里处理下拉刷新或者上拉加载更多 * @param event * @return */@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch(event.getAction())&#123; case MotionEvent.ACTION_MOVE: int currentY = (int) event.getRawY(); mYOffset = currentY - mLastY; if(mCurrentStatus != STATUS_LOADING)&#123; changeScrollY(mYOffset); &#125; rotateHeaderArrow(); changeTips(); mLastY = currentY; break; case MotionEvent.ACTION_UP: //下拉刷新具体操作 doRefresh(); break; default: break; &#125; return true;//返回 true，消费该事件&#125;protected void doRefresh() &#123; changeHeaderViewStaus(); if(mCurrentStatus == STATUS_REFRESHING &amp;&amp; mOnRefreshListener != null)&#123; mOnRefreshListener.onRefresh(); &#125;&#125; 在 onTouchEvent 函数中，判断他的事件类型。如果还是 MOVE，就计算 y 坐标的差值，在此处调用 changeScrollY 函数，在 y 轴上滚动该控件，另外还有改变箭头方向，文字提示等。如果是 ACTION_UP 手指抬起，说明松手了，就执行下拉刷新操作。当然执行的时候要判断 y坐标下拉的偏移值够不够。 123456789101112131415161718/** * 刷新结束时候调用，视图还原为基本状态 */public void refreshComplete()&#123; mScroller.startScroll(getScrollX(),getScrollY(),0,mInitScrollY - getScrollY()); mCurrentStatus = STATUS_IDLE; invalidate(); updateHeaderTimeStamp(); //100毫秒之后处理arrow和progress，免得太突兀 this.postDelayed(new Runnable() &#123; @Override public void run() &#123; mArrowImageView.setVisibility(View.VISIBLE); mProgressBar.setVisibility(View.GONE); &#125; &#125;,100);&#125;]]></content>
      <categories>
        <category>Android 自定义控件</category>
      </categories>
      <tags>
        <tag>Android 自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android项目结构]]></title>
    <url>%2F2017%2F05%2F03%2FAndroid%20%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%2Fandroid%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[规范1.AS 规范 尽量使用最新版的IDE进行开发； 编码格式统一为UTF-8； 编辑完.java、 .xml等文件后一定要格式化（基本格式方面使用 AS 默认模板即可）； 删除多余的import，减少警告出现，可利用AS的Optimize Imports(Settings → Keymap → Optimize Imports)快捷键； 2.命名规范包名全部小写，连续的单词只是简单地连接起来，不使用下划线，采用反域名命名规则，全部使用小写字母。 一级包名是顶级域名，通常为com,edu,gov,net,org等，二级包名为公司名，三级包名根据应用进行命名，后面就是对包名的划分了，关于包名的划分，推荐使用按功能分。比如像这样： 或者参考谷歌 I/O 2015 的代码结构： 类名名词，采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的， 比如HTML, URL，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。 类 描述 例如 Activity 类 Activity为后缀标识 欢迎页面类WelcomeActivity Adapter类 Adapter 为后缀标识 新闻详情适配器 NewDetailAdapter 解析类 Parser为后缀标识 首页解析类HomePosterParser 工具方法类 Utils或Manager为后缀标识（与系统或第三方的Utils区分）或功能+Utils 线程池管理类：ThreadPoolManager日志工具类：LogUtils（Logger也可）打印工具类：PrinterUtils 数据库类 以DBHelper后缀标识 新闻数据库：NewDBHelper Service类 以Service为后缀标识 时间服务TimeService BroadcastReceiver类 以Receiver为后缀标识 推送接收JPushReceiver ContentProvider类 以Provider为后缀标识 ShareProvider 自定义的共享基础类 以Base开头 BaseActivity,BaseFragment 接口（interface）：命名规则与类一样采用大驼峰命名法，多以able或ible结尾，如： interface Runnable、interface Accessible。 注意：如果项目采用MVP，所有Model、View、Presenter的接口都以I为前缀，不加后缀，其他的接口采用上述命名规则。 方法 方法 说明 initXX() 初始化相关方法,使用init为前缀标识，如初始化布局initView() isXX() checkXX() 方法返回值为boolean型的请使用is或check为前缀标识 getXX() 返回某个值的方法，使用get为前缀标识 setXX() 设置某个属性值 handleXX()/processXX() 对数据进行处理的方法 displayXX()/showXX() 弹出提示框和提示信息，使用display/show为前缀标识 updateXX() 更新数据 saveXX() 保存数据 resetXX() 重置数据 clearXX() 清除数据 removeXX() 移除数据或者视图等，如removeView(); drawXX() 绘制数据或效果相关的，使用draw前缀标识 3.资源文件3.1.1 contentView命名必须以全部单词小写，单词间以下划线分割，使用名词或名词词组。 所有Activity或Fragment的contentView必须与其类名对应，对应规则为：将所有字母都转为小写，将类型和功能调换（也就是后缀变前缀）。 例如：activity_main.xml 3.1.5 包含项命名规则：模块_(位置)描述.xml 例如：activity_main_head.xml、activity_main_bottom.xml 注意：通用的包含项命名采用：项目名称缩写_描述.xml 例如：xxxx_title.xml 3.2 资源文件（图片drawable文件夹下）全部小写，采用下划线命名法，加前缀区分 命名模式：可加后缀 _small 表示小图， _big 表示大图，逻辑名称可由多个单词加下划线组成，采用以下规则： 用途模块名逻辑名称 用途模块名颜色 用途_逻辑名称 用途_颜色 说明：用途也指控件类型（具体见附录UI控件缩写表） http://www.jianshu.com/p/419f5357357d#ui%E6%8E%A7%E4%BB%B6%E7%BC%A9%E5%86%99%E8%A1%A8 例如： 名称 说明 btn_main_home.png 按键用途模块名逻辑名称 divider_maket_white.png 分割线用途模块名颜色 ic_edit.png 图标用途_逻辑名称 bg_main.png 背景用途_逻辑名称 btn_red.png 红色按键用途_颜色 btn_red_big.png 红色大按键用途_颜色 ic_head_small.png 小头像用途_逻辑名称 bg_input.png 输入框背景用途_逻辑名称 divider_white.png 白色分割线用途_颜色 bg_main_head 主模块头部背景图片用途模块名逻辑名称 def_search_cell 默认搜索界面单元图片用途模块名逻辑名称 ic_more_help 更多帮助图标用途_逻辑名称 divider_list_line 列表分割线用途_逻辑名称 selector_search_ok 搜索界面确认选择器用途模块名逻辑名称 shape_music_ring 音乐界面环形形状用途模块名逻辑名称 如果有多种形态，如按钮选择器：btn_xx.xml(selector) 名称 说明 btn_xx 按钮图片使用btn_整体效果（selector） btn_xx_normal 按钮图片使用btn_正常情况效果 btn_xx_pressed 按钮图片使用btn_点击时候效果 btn_xx_focused state_focused聚焦效果 btn_xx_disabled state_enabled (false)不可用效果 btn_xx_checked state_checked选中效果 btn_xx_selected state_selected选中效果 btn_xx_hovered state_hovered悬停效果 btn_xx_checkable state_checkable可选效果 btn_xx_activated state_activated激活的 btn_xx_windowfocused state_window_focused 注意：使用AndroidStudio的插件SelectorChapek可以快速生成selector，前提是命名要规范。 3.3 动画文件（anim文件夹下）全部小写，采用下划线命名法，加前缀区分。 具体动画采用以下规则：模块名_逻辑名称。 例如：refresh_progress.xml、market_cart_add.xml、market_cart_remove.xml。 普通的tween动画采用如下表格中的命名方式：动画类型_方向 名称 说明 fade_in 淡入 fade_out 淡出 push_down_in 从下方推入 push_down_out 从下方推出 push_left 推向左方 slide_in_from_top 从头部滑动进入 zoom_enter 变形进入 slide_in 滑动进入 shrink_to_middle 中间缩小]]></content>
      <categories>
        <category>Android 项目基础</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>规范</tag>
      </tags>
  </entry>
</search>