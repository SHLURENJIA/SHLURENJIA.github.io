<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 调用相机相册并上传图片]]></title>
    <url>%2F2017%2F11%2F08%2FAndroid%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FAndroid%20%E8%B0%83%E7%94%A8%E7%9B%B8%E6%9C%BA%E7%9B%B8%E5%86%8C%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[前言头像几乎是每个应用必备的，那么上传头像需要怎么样的操作呢？ 最基本的就是使用相机或者从相册选取图片，裁剪压缩过后，上传到服务器。 拍照/从相册中选取打开相机弹窗提示选择拍照或者从相册中选取图片。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 /** * 点击更换项目头像 * 可以选择拍照或者从相册选取 * 图片需要经过裁剪压缩上传 */ @OnClick(R.id.iv_project_img) public void changeProjectImg()&#123; //此处进行弹窗选择处理 AlertDialog.Builder alertDialog = new AlertDialog.Builder(this); alertDialog.setTitle("更换项目头像"); alertDialog.setItems(new String[]&#123;"拍照", "从相册选取"&#125;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; switch(which)&#123; case 0: //拍照,调用系统相机 //创建File，用于存储拍照后的图片 File outputImage = new File(getExternalCacheDir(),"output_image.jpg"); try &#123; if (outputImage.exists()) &#123; outputImage.delete(); &#125; outputImage.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //启动相机程序 Intent intent = new Intent("android.media.action.IMAGE_CAPTURE"); if(SDK_INT &gt;= 24)&#123; imageUri = FileProvider.getUriForFile(CreateProjectActivity.this, "com.example.cameraalbumtest.fileprovider", outputImage); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);//这里加入flag intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); &#125; else &#123; imageUri = Uri.fromFile(outputImage); &#125; intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); startActivityForResult(intent, TASK_PHOTO); break; case 1: //权限检查，动态申请权限。 //相册存于SD卡，所以要 WRITE_EXTERNAL_STORAGE 授予对SD卡的读写权限 if(ContextCompat.checkSelfPermission(CreateProjectActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(CreateProjectActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125; else &#123; //打开相册 openAlbum(); &#125; break; default: break; &#125; &#125; &#125;); alertDialog.show(); &#125;/*** 申请权限结果返回处理*/ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch(requestCode)&#123; case 1: if(grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125; else &#123; Toast.makeText(this, "没有权限，无法打开相册！", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125; &#125; 由于使用了provider，还需要再Manifest文件那里声明，并且在res下new directory ，包名为xml，然后再新建一个xml文件，文件名为file_paths。代码如下： Manifest.xml: 12345678910111213141516&lt;application ··· &gt; &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.example.cameraalbumtest.fileprovider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths"/&gt; &lt;/provider&gt; ··· &lt;/application&gt; file_paths.xml: 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;Paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="my_images" path=""/&gt;&lt;/Paths&gt; 至此，调用系统相机基本完成。 打开相册123456789101112131415161718192021222324252627/** * 打开相册 */ private void openAlbum() &#123; File galleryFile = new File(getExternalCacheDir(),"crop_image.jpg"); try &#123; if (galleryFile.exists()) &#123; galleryFile.delete(); &#125; galleryFile.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Intent intentAlbum = new Intent("android.intent.action.GET_CONTENT"); intentAlbum.addCategory(Intent.CATEGORY_OPENABLE); intentAlbum.setType("image/*"); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;//如果大于等于7.0使用FileProvider Uri uriForFile = FileProvider.getUriForFile (this, "com.example.cameraalbumtest.fileprovider", galleryFile); intentAlbum.putExtra(MediaStore.EXTRA_OUTPUT, uriForFile); intentAlbum.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); intentAlbum.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); &#125; else &#123; intentAlbum.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(galleryFile)); &#125; startActivityForResult(intentAlbum, CHOSE_PHOTO); &#125; 裁剪处理先接收返回的图片，转换成对应的Uri，然后调用裁剪（crop）方法进行裁剪。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** * 此处处理返回的图片 * @param requestCode * @param resultCode * @param data */ @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch(requestCode)&#123; case TASK_PHOTO://拍照 if(resultCode == RESULT_OK)&#123; File temp = new File(getExternalCacheDir(),"output_image.jpg"); Uri photoUri; if(SDK_INT &gt;= 24)&#123; photoUri = FileProvider.getUriForFile(CreateProjectActivity.this, "com.example.cameraalbumtest.fileprovider", temp); &#125; else &#123; photoUri = Uri.fromFile(temp); &#125; crop(photoUri); &#125; break; case CHOSE_PHOTO: if(resultCode == RESULT_OK)&#123; //判断手机系统版本号 if(Build.VERSION.SDK_INT &gt;= 19)&#123; //4.4及以上可以使用此方法处理图片 handleImageOnKitkat(data); &#125; else &#123; handleImageBeforeKitkat(data); &#125; &#125; case CUT_PHOTO: File temp = new File(getExternalCacheDir(),"crop_image.jpg"); Uri imageUri = FileProvider.getUriForFile(CreateProjectActivity.this, "com.example.cameraalbumtest.fileprovider", temp); Bitmap bitmap = null; try &#123; bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; mProjectImg.setImageBitmap(bitmap); break; default: break; &#125; &#125; protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch(requestCode)&#123; case TASK_PHOTO: if(resultCode == RESULT_OK)&#123; try &#123; Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri)); mProjectImg.setImageBitmap(bitmap); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; break; default: break; &#125; &#125; private void handleImageBeforeKitkat(Intent data) &#123; Uri uri = data.getData(); crop(uri); &#125; /** * 相册返回图片处理。 * 大于4.4版本 * @param data 相册返回的Intent */ @TargetApi(19) private void handleImageOnKitkat(Intent data) &#123; String imagePath = null; Uri uri = data.getData(); if(DocumentsContract.isDocumentUri(this,uri))&#123; //如果是Document类型的uri，则通过 document id 处理 String docId = DocumentsContract.getDocumentId(uri); if("com.android.providers.media.documents".equals(uri.getAuthority())) &#123; String id = docId.split(":")[1];//解析出数字格式的id String selection = MediaStore.Images.Media._ID + "=" + id; imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection); &#125; else if ("com.android.providers.downloads.documents".equals(uri.getAuthority()))&#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"), Long.valueOf(docId)); imagePath = getImagePath(contentUri, null); &#125; &#125; else if ("content".equalsIgnoreCase(uri.getScheme()))&#123; //如果是普通类型的Uri，则使用普通当时处理 imagePath = getImagePath(uri, null); &#125; else if ("file".equalsIgnoreCase(uri.getScheme())) &#123; //如果是File类型的uri，直接获取图片路径即可 imagePath = uri.getPath(); &#125; //根据图片路径显示图片 //displayImage(imagePath); //Environment.getExternalStorageDirectory() + "/" + File temp = new File(imagePath); Uri imgUri; if(SDK_INT &gt;= 24) &#123; imgUri = FileProvider.getUriForFile(this, "com.example.cameraalbumtest.fileprovider", temp); &#125; else &#123; imgUri = Uri.fromFile(temp); &#125; crop(imgUri); &#125; /** * 通过uri和selection来获取图片的真实路径 * @param uri * @param selection * @return */ private String getImagePath(Uri uri, String selection) &#123; String path = null; //通过uri和selection来获取图片的真是路径 Cursor cursor = getContentResolver().query(uri, null, selection, null, null); if(cursor != null)&#123; if(cursor.moveToFirst())&#123; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path; &#125; 裁剪图片方法如下 12345678910111213141516171819202122232425262728293031323334353637383940/** * 裁剪图片 * @param uri */private void crop(Uri uri)&#123; File cropFile = new File(getExternalCacheDir(),"crop_image.jpg"); try &#123; if (cropFile.exists()) &#123; cropFile.delete(); &#125; cropFile.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Intent intent = new Intent("com.android.camera.action.CROP"); if(SDK_INT &gt;= 24)&#123; Uri outputUri = Uri.fromFile(cropFile); intent.setDataAndType(uri, "image/*"); intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); &#125; else &#123; Uri outputUri = Uri.fromFile(cropFile); intent.setDataAndType(uri, "image/*"); intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri); &#125; intent.putExtra("crop","true"); //裁剪框的比例为1:1 intent.putExtra("aspectX",1); intent.putExtra("aspectY",1); //裁剪后输出图片的尺寸大小 intent.putExtra("outputX",250); intent.putExtra("outputY",250); //图片格式 intent.putExtra("outputFormat","PNG"); intent.putExtra("noFaceDetection", false);// 取消人脸识别 intent.putExtra("return-data", false);// true:不返回uri，false：返回uri startActivityForResult(intent, CUT_PHOTO);//同样的在onActivityResult中处理剪裁好的图&#125; 以上，一个本地的拍照/打开相册更换图片基本就完成了。然后就是把图片上传到服务器。 把图片上传到服务器我使用的是 retrofit 网络请求框架，上传对他来说也很简单。同时因为后台是后端云Bmob，文档上说支持文本和二进制流的方式上传，所以我没有用@Multipart 进行传输，只是普通的RequestBody。代码如下： 1234567891011121314151617181920212223242526272829303132333435public interface IImagePost&#123; @POST("2/files/&#123;fileName&#125;") @Headers(&#123; "X-Bmob-Application-Id:xxx", "X-Bmob-REST-API-Key:xxx", "Content-Type:application/x-png" &#125;) Call &lt;ImageResult&gt; imagePost(@Path("fileName") String fileName, @Body RequestBody file);&#125;//-------------public void imagePost(File file, final ResultCallback resultCallback)&#123; IImagePost iImagePost = mRetrofit.create(IImagePost.class); RequestBody requestFile = RequestBody .create(MediaType.parse("multipart/form-data"), file); Call&lt;ImageResult&gt; call = iImagePost.imagePost(file.getName(), requestFile); call.enqueue(new Callback&lt;ImageResult&gt;() &#123; @Override public void onResponse(Call&lt;ImageResult&gt; call, Response&lt;ImageResult&gt; response) &#123; try &#123; resultCallback.onSuccess(response); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(Call&lt;ImageResult&gt; call, Throwable t) &#123; resultCallback.onFailed(); &#125; &#125;);&#125; ResultCallback 是我自定义的接口回调，在图片裁剪上传的类中可以这样调用： 123456789101112131415161718192021/*** 将头像上传到服务器*/private void ImageUpload()&#123; File temp = new File(getExternalCacheDir(),"crop_image.png"); HttpUtil.getInstance().imagePost(temp, new HttpUtil.ResultCallback() &#123; @Override public void onFailed() &#123; Toast.makeText(CreateProjectActivity.this, "连接服务器失败", Toast.LENGTH_SHORT).show(); &#125; @Override public void onSuccess(Response response) throws IOException &#123; if(response.isSuccessful())&#123; mImageResult = (ImageResult) response.body(); //返回图片的url等信息，自行处理 &#125; &#125; &#125;);&#125; 以上，一个调取系统相机拍照/从相册中获取图片，然后裁剪，上传的基本功能就完成了。 PS：这里没有对图片进行压缩处理，留待完善。]]></content>
      <categories>
        <category>Android 基础学习</category>
      </categories>
      <tags>
        <tag>相机</tag>
        <tag>上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大组件——ContentProvider 相关]]></title>
    <url>%2F2017%2F11%2F08%2FAndroid%20%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94ContentProvider-%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[ContentProvider简介​ ContentProvider 是用来跨程序共享数据的。比如很常见的访问短信，通信录，还有手机相册。他提供了一套完整的机制，允许一个程序访问另外一个程序中的数据，同时还能保证访问数据的安全性。 ​ 不过在对此深入前，还要先掌握运行时权限。 运行时权限​ 权限机制一直都有，我们一般就是在 Menifest 里面注册一下。事实上这样的权限对用户安全和隐私一直都是很鸡肋的状态，耍起流氓来让用户苦不堪言。然后 6.0 就增加了运行时权限这个功能。(适配工作量增加了不少XD ​ 运行时权限，顾名思义，就是在运行的时候，需要用到什么权限，就申请什么权限，还要用户手动点击确认才授予。这就很棒棒了。当然不会什么权限都需要这样子申请，不然用户也很烦。Android 现在将权限分为普通权限和危险权限，其区分标准就是会不会威胁到用户的隐私，或者对设备安全性造成影响。危险权限分为9组24个。 ​ 要注意的是，我们在申请这些危险权限的时候，如果是申请某一个危险权限，用户同意授权后，那么该权限所在的整组权限也会同时被授予。]]></content>
      <tags>
        <tag>ContentProvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[retrofit 相关]]></title>
    <url>%2F2017%2F11%2F08%2FAndroid%20%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6%2Fretrofit-%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[基础知识]]></title>
    <url>%2F2017%2F11%2F08%2FAndroid%20%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[谈谈你对fragment的理解？ 对xx的理解，一般从是什么？在什么场景应用，最好还可以延伸一下注意事项。 fragment 又称为碎片，可以作为界面使用。他有自己的生命周期，可以直接处理一些用户交互，但是却是依附于 Activity 的生命周期。一般来说，在平板开发，还有 tab 切换中应用得比较多。]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法学习]]></title>
    <url>%2F2017%2F11%2F07%2FAndroid%20%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[排序选择排序(不稳定) 主要思想： 在未排序序列中找出最小的元素，添加到有序序列中。 思路： 将整个序列分为无序区和有序区，初始时候有序区为空，无序区含有待排序的所有记录。 在无序区中选取最小的元素，将它与无序区的第一个元素交换，使得有序区扩展了一位，同时无序区减少了一位。 重复 2 ，直到无序区只剩下一个记录为之。此时所有的记录已经从小到大排序完毕。 代码实现 123456789101112131415161718public static void sort(int[] array)&#123; int len = array.length; for (int i = 0; i &lt; len; i++)&#123; //对n个元素进行n-1次简单排序 int index = i; for(int j = i + 1; j &lt; len; j++)&#123; //在这层循环里面找出最小的元素 if(array[j] &lt; array[index])&#123; index = j; &#125; &#125; if(index != i)&#123; int tem = array[i]; array[i] = array[index]; array[index] = tem; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android 面试集锦</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中图片的三级缓存]]></title>
    <url>%2F2017%2F10%2F21%2FAndroid%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FAndroid%20%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[什么是三级缓存？ 内存缓存，优先加载，速度最快 本地缓存，次优先加载，速度快 网络缓存，最后加载，速度慢，浪费流量 ##为什么要进行三级缓存 三级缓存策略，最实在的意义就是减少不必要的流量消耗，增加加载速度。 如今的 APP 网络交互似乎已经必不可少，通过网络获取图片再正常不过了。但是，每次启动应用都要从网络获取图片，或者是想重复浏览一些图片的时候，每次浏览都需要网络获取，消耗的流量就多了，在如今的流量资费来说，肯定会容易影响用户数量。 还有就是网络加载图片，有时候会加载很慢，影响了用户体验。 另外从开发角度来说，Bitmap 的创建非常消耗时间和内存，可能导致频繁GC。而使用缓存策略，会更加高效地加载 Bitmap，减少卡顿，从而减少读取时间。 而内存缓存的主要作用是防止应用重复将图片数据读取到内存当中，硬盘缓存则是防止应用重复从网络或其他地方重复下载和读取数据。 三级缓存的原理 首次加载的时候通过网络加载，获取图片，然后保存到内存和 SD 卡中。 之后运行 APP 时，优先访问内存中的图片缓存。 如果内存没有，则加载本地 SD 卡中的图片。 ​ 具体的缓存策略可以是这样的：内存作为一级缓存，本地作为二级缓存，网络加载为最后。其中，内存使用 LruCache ，其内部通过 LinkedhashMap 来持有外界缓存对象的强引用；对于本地缓存，使用 DiskLruCache。加载图片的时候，首先使用 LRU 方式进行寻找，找不到指定内容，按照三级缓存的方式，进行本地搜索，还没有就网络加载。 ##图片缓存代码实现 自己实现一个三级缓存的工具类并不困难。大概可以这样： 123456789101112131415161718192021222324252627282930public class BitmapUtil&#123; //单例模式 //··· public void displayImage(ImageView img, String url)&#123; Bitmap bitmap; //内存缓存，url做唯一标识符 bitmap = loadBitmapFromMemoryCache(url); if(bitmap != null)&#123; img.setImageBitmap(bitmap); return ; &#125; //本地缓存 bitmap = loadBitmapFromDiskCache(url); if(bitmap != null)&#123; img.setImageBitmap(bitmap); //然后将本地缓存保存到内存缓存中 return ; &#125; //网络缓存 bitmap = loadBitmapFromNet(url); if(bitmap != null)&#123; img.setImageBitmap(bitmap); //同理将缓存保存到内存和本地中 return; &#125; &#125; &#125; 详细不说了，网上有很多类似的文章可以参考。 关于内存缓存的实现核心基本就是获取APP最大内存，然后set的时候用LruCache&lt; url , bitmap&gt; put 进去。他会按照最近最少使用的算法将内存控制在一定大小内，超出的时候自动回收。 还有一点注意的是，一般url作为 key 的时候，会用MD5算法处理一下，最后是用其 MD5 值作为key的，这可能是为了避免一些特殊字符影响使用。 关于Glide的缓存事实上，现在已经很少自己封装一个三级缓存策略，在众多的图片框架中都加入缓存策略，实现起来更简单。这里以 Glide 为例。 Glide 的使用基本就是一行代码就解决了。像下面这样 123456789101112131415// 加载本地图片File file = new File(getExternalCacheDir() + "/image.jpg");Glide.with(this).load(file).into(imageView);// 加载应用资源int resource = R.drawable.image;Glide.with(this).load(resource).into(imageView);// 加载二进制流byte[] image = getImageBytes();Glide.with(this).load(image).into(imageView);// 加载Uri对象Uri imageUri = getImageUri();Glide.with(this).load(imageUri).into(imageView); 当然应用到项目里面最好二次封装一下。这些不是这次文章的主题。我们回到缓存上面来。 Glide 的内存缓存Glide 是默认开启了内存缓存的，只要你通过 Glide 加载一张图片，他就会缓存到内存中，只要他还没被从内存中清理之前，下次使用 Glide 都会从内存缓存中加载。大大提升了图片加载的效率。 当然如果你有特殊要求，可以添加一行代码把默认开启的内存缓存关闭掉。 1234Glide.with(this) .load(url) .skipMemoryCache(true)//关闭内存缓存 .into(imageView); Glide 的内存缓存实际上和我们上面说的差别不大，使用的也是LruCache算法，不过他还结合了一种弱引用机制，共同完成了内存缓存功能。 详情可以看文末参考文章郭霖大神关于Glide源码的解析。 Glide 的硬盘缓存关于 Glide 硬盘缓存使用也是十分简单。 1234Glide.with(this) .load(url) .diskCacheStrategy(DiskCacheStrategy.RESULT) .into(imageView); 一个 diskCacheStrategy( ) 方法就可以调整他的硬盘缓存策略。其中可以传入的参数有四种： DiskCacheStrategy.NONE： 表示不缓存任何内容。 DiskCacheStrategy.SOURCE： 表示只缓存原始图片。 DiskCacheStrategy.RESULT： 表示只缓存转换过后的图片（默认选项）。 DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。 Glide 的硬盘缓存是默认将图片压缩转换后再缓存到硬盘中，这种处理方式再避免OOM的时候会经常看见。 如果需要改变硬盘缓存策略只需要改变其传入的参数即可。 参考文章： Android图片加载框架最全解析（三），深入探究Glide的缓存机制 —— 郭霖 Android中图片的三级缓存——wanbo_]]></content>
      <categories>
        <category>Android 基础学习</category>
      </categories>
      <tags>
        <tag>图片缓存</tag>
        <tag>缓存策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 MonkeyRunner 进行自动化测试]]></title>
    <url>%2F2017%2F07%2F22%2FAndroid%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%2F%E4%BD%BF%E7%94%A8%20MonkeyRunner%20%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[这篇文章记录一下 Monkeyrunner 的使用。因为本人也是刚接触，如有错漏，请指正。 准备 python 基础。 说是基础，会点基本用法循环条件就差不多了。有语言基础的话还是很快入门的。我当时是看菜鸟教程，配一下环境就行了。 JDK、SDK 环境 monkeyrunner monkeyrunner 是 SDK.tools 下的一个 .bat 文件，是 Android 自带的工具。配合 py 脚本可以模拟手机点击、拖拽、功能键等的实现，然后可以观察截图自己比较。只要你事先写好脚本，一系列动作，他就能模拟运行，达到自动化测试的目的。 如果目录下没有，可能你是AS下的SDK，那么应该在 tools.bin 目录下。 monkeyrunner 方法导入需要的模块主要包括三个模块 1、MonkeyRunner:这个类提供了用于连接monkeyrunner和设备或模拟器的方法，它还提供了用于创建用户界面显示提供了方法。 2、MonkeyDevice:代表一个设备或模拟器。这个类为安装和卸载包、开启Activity、发送按键和触摸事件、运行测试包等提供了方法。 3、MonkeyImage:这个类提供了捕捉屏幕的方法。这个类为截图、将位图转换成各种格式、对比两个MonkeyImage对象、将image保存到文件等提供了方法。 12345678910#引入模块from com.android.monkeyrunner import MonkeyRunner,MonkeyDevice,MonkeyImage#或者给模块起别名，引用的时候就不用写全称。#但是引用了别名就不能使用原来的名字了，否则报错import sysfrom com.android.monkeyrunner import MonkeyRunner as mrfrom com.android.monkeyrunner import MonkeyDevice as mdfrom com.android.monkeyrunner import MonkeyImage as mi#比如连接设备或模拟器，起了以上别名后，命令应该如下：device=mr.waitForConnection() 启动活动启动活动要先连接设备，就是上面 waitForConnection() 的代码。然后就是要调用 123device.startActivity(component="&lt;packageName&gt;/&lt;packageName&gt;.&lt;activityName&gt;")#或者device.startActivity(component="&lt;packageName&gt;/.&lt;activityName&gt;")` 自己开发的可以去查看 Manifest 文件，不是自己开发的软件，我查了一下。用了同是 SDK.tools 下的 Android 自带的工具：hierarchyviewer.bat 或者用重签名工具，在这里不累述了，一查就知道。 得到包名和活动名，你就可以进行自动化测试了。 方法点击123456#在指定位置发送触摸事件 #device.touch(x,y,触摸事件类型)#x,y的单位为像素#触摸事件类型，请见下文中Findyou对device.press描述device.touch(520,520,'DOWN_AND_UP') 发送到指定键的一个关键事件1234567891011121314151617181920#device.press(参数1:键码,参数2:触摸事件类型)#参数1：见android.view.KeyEvent#参数2，如有TouchPressType()返回的类型－触摸事件类型，有三种。#1、DOWN 发送一个DOWN事件。指定DOWN事件类型发送到设备，对应的按一个键或触摸屏幕上。#2、UP 发送一个UP事件。指定UP事件类型发送到设备，对应释放一个键或从屏幕上抬起。#3、DOWN_AND_UP 发送一个DOWN事件，然后一个UP事件。对应于输入键或点击屏幕。#以上三种事件做为press()参数或touch()参数#按下HOME键device.press('KEYCODE_HOME',MonkeyDevice.DOWN_AND_UP) #按下BACK键device.press('KEYCODE_BACK',MonkeyDevice.DOWN_AND_UP) #按下下导航键device.press('KEYCODE_DPAD_DOWN',MonkeyDevice.DOWN_AND_UP) #按下上导航键device.press('KEYCODE_DPAD_UP',MonkeyDevice.DOWN_AND_UP) #按下OK键device.press('KEYCODE_DPAD_CENTER',MonkeyDevice.DOWN_AND_UP) 按下HOME键 device.press(‘KEYCODE_HOME’,MonkeyDevice.DOWN_AND_UP) home键 KEYCODE_HOME back键 KEYCODE_BACK send键 KEYCODE_CALL 上音量键 KEYCODE_VOLUME_UP 下音量键 KEYCODE_VOLUME_DOWN power键 KEYCODE_POWER camera键 KEYCODE_CAMERA menu键 KEYCODE_MENU 更多：http://developer.android.com/reference/android/view/KeyEvent.html 键盘输入123#字符串发送到键盘 #device.type('字符串')device.type('Findyou') 滑动1234567#模拟滑动#device.drag(X,Y,D,S)#X 开始坐标#Y 结束坐标#D 拖动持续时间(以秒为单位)，默认1.0秒#S 插值点时要采取的步骤。默认值是10device.drag((100,1053),(520,1053),0.1,10) 截屏1234result=device.takeSnapshot()#返回一个MonkeyImage对象（点阵图包装），我们可以用以下命令将图保存到文件result.writeToFile('E:\\JAVA\\monkeyrunner\\Test1\\Test1_001.png','png')#&lt;path&gt;\\&lt;fileName&gt;.png 实例 把你的 py 脚本放到 monkeyrunner 所在的目录 命令行进入该目录，输入命令：monkeyrunner.bat test.py 测试输出成功。 如果提示monkeyrunner不是内部或外部命令，请回去配置环境变量。 手机获取模拟器打开开发者选项的指针位置功能，方便获取坐标。然后可以开始编写py脚本了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# -*- coding: utf-8 -*- # 上面那句是为了支持中文注释。文件请保存 utf-8 格式免得出问题#引入模块from com.android.monkeyrunner import MonkeyRunner,MonkeyDevice,MonkeyImageimport timeimport os#连接设备device=MonkeyRunner.waitForConnection() #启动Activity（此处为启动模拟器的浏览器）mPackageName = "com.android.browser"mActivityName = "com.android.browser.BrowserActivity"mRunComponent = mPackageName + "/" + mActivityName#获取时间def getNowTimeUnderline(): return time.strftime("_%H_%M_%S",time.localtime(time.time())) #获取日期def getToday(): return time.strftime("%Y_%m_%d",time.localtime(time.time()))#截图并保存def shotPhoto(): newimage = device.takeSnapshot() newimage.writeToFile ("ImageFile/" + getToday() + getNowTimeUnderline() + ".png" , "png") time.sleep(1.0)#创建存储截图的文件夹def mkdirPath(path): if not os.path.exists(path): os.mkdir(path)#创建文件夹mkdirPath("ImageFile")#启动应用device.startActivity(component = mRunComponent)time.sleep(3.0)#启动Acticity的时间for slipCount in range(1,3):#迭代1到3之间，相当于循环两次。 device.drag( (385,1032), (385,700), 1.0, 10 )#向上滑动 time.sleep(2.0) shotPhoto()device.touch(399, 73, "DOWN_AND_UP")#单击该坐标（网址输入栏）time.sleep(1.0)shotPhoto()device.type('https://shlurenjia.github.io')#键盘输入网址，这是我的博客time.sleep(1.0)device.press('KEYCODE_ENTER', MonkeyDevice.DOWN_AND_UP)#enter 确认跳转time.sleep(5.0)shotPhoto()device.touch(325, 357, "DOWN_AND_UP")#点击第一篇文章time.sleep(1.0)shotPhoto()device.press('KEYCODE_BACK','DOWN_AND_UP') #第二个参数也可以这样简写time.sleep(2.0)shotPhoto()device.press('KEYCODE_BACK','DOWN_AND_UP') time.sleep(2.0)shotPhoto() 截图可以让你挂完脚本之后自己比对效果。每个动作后面加上 sleep 因为要考虑到手机响应的时间。不然脚本执行下去很容易报错 Error sending xxx event 效果由于加了sleep，所以看起来比较慢 ​ 截图文件： ​ ​ ​]]></content>
      <categories>
        <category>Android 自动化测试</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>Monkeyrunner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 首页轮播图和list混合（RecyclerView 添加 Header）]]></title>
    <url>%2F2017%2F07%2F01%2FAndroid%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FAndroid%20%E9%A6%96%E9%A1%B5%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%92%8Clist%E6%B7%B7%E5%90%88%EF%BC%88RecyclerView%20%E6%B7%BB%E5%8A%A0%20Header%EF%BC%89%2F</url>
    <content type="text"><![CDATA[使用 convenientBanner 轮播图给 RecyclerView 添加 header先来看看效果图。我们要实现的就是上面轮播图轮播，下面是列表 list 展示数据。实际应用中很多都会使用轮播图去插入广告，活动等。 那么我们要怎么实现呢？ 思路有很多，可以用 ViewPager 去实现轮播图，不过使用比较麻烦，要自己实现无限循环轮播，自动轮播等。 还可以用 RecyclerView 去打造一个轮播图。LinearSnapHelper 可以帮助你滑动停止的时候某页居中。设置定时器可以实现自动轮播。 这里我们并不使用以上的方法，我们使用外部的框架 convenientBanner 去直接使用轮播图。有关详细使用可以搜一下或者点github地址 有说明。 项目开始新建之后添加依赖 1234// 轮播器compile 'com.bigkoo:convenientbanner:2.0.5'//图片加载框架compile 'com.github.bumptech.glide:glide:3.7.0' 因为这里的例子是使用网络图片加载的方式，所以还要添加网络权限和存储权限。 12&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt; 布局主布局添加 RecyclerView 即可。整个主界面其实就是一个 RecyclerView，轮播图其实是 Rv 根据不同的 Type 添加不同的 View 来放到 Rv 头部的。后面会再提到。 另外就是 rv_header_banner.xml，这个就是放到 Rv 头部的。 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;com.bigkoo.convenientbanner.ConvenientBanner xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/banner" android:layout_width="match_parent" android:layout_height="match_parent" app:canLoop="true" /&gt; 还有一个 rv_header_img.xml。这个是构建 Banner 的视图的时候用到。 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ImageView android:id="@+id/iv_head" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop"/&gt;&lt;/LinearLayout&gt; 最后一个 rv_item.xml，这个是展示 list 数据。 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;TextView android:id="@+id/tv_item" android:layout_marginBottom="20dp" android:textSize="20sp" android:text="item" android:layout_alignParentBottom="true" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt;&lt;/RelativeLayout&gt; 以上布局基本完成。 细心的人会发现，轮播图那里有几个小点指示器。这个的样式是我们自定义的。所以我们这里还要在 drawable 下新建两个圆点的样式文件 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape android:shape="oval" xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;solid android:color="#BDBDBD"/&gt; &lt;size android:height="10dp" android:width="10dp"/&gt;&lt;/shape&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval"&gt; &lt;solid android:color="#D32F2F"/&gt; &lt;size android:width="10dp" android:height="10dp"/&gt;&lt;/shape&gt; Adapter在这里，Adapter 配置的核心是根据不同的 itemType 加载不同的 View。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * 根据不同的 ViewType 返回不同的 ViewHolder * 通过 setter 方法将不同的 View 注入进 Adapter */public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123; public static final int TYPE_HEADER = 0; public static final int TYPE_NOMAL = 1; private View mHeaderView; private List&lt;String&gt; mDatas = new ArrayList&lt;&gt;(); private OnItemClickListener mListener; public View getmHeaderView() &#123; return mHeaderView; &#125; public void setmHeaderView(View mHeaderView) &#123; this.mHeaderView = mHeaderView; notifyItemInserted(0);//插入下标0位置 &#125; public void addDatas(List&lt;String&gt; datas)&#123; mDatas.addAll(datas); notifyDataSetChanged(); &#125; @Override public int getItemViewType(int position) &#123; if(mHeaderView == null)&#123; return TYPE_NOMAL; &#125; if(position == 0)&#123; return TYPE_HEADER; &#125; return TYPE_NOMAL; &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if(mHeaderView != null &amp;&amp; viewType == TYPE_HEADER)&#123; return new MyViewHolder(mHeaderView); &#125; View itemView = LayoutInflater.from(parent.getContext()).inflate(R.layout.rv_item, parent, false); return new MyViewHolder(itemView); &#125; @Override public void onBindViewHolder(MyViewHolder holder, int position) &#123; if (getItemViewType(position) == TYPE_HEADER) &#123; return; &#125; final int pos = getRealPosition(holder);//这里的 position 实际需要不包括 header final String data = mDatas.get(pos); holder.textView.setText(data); if(mListener == null) return; holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mListener.onItemClick(pos, data); &#125; &#125;); &#125; /** * 添加头部布局后的位置 * headerView 不为空则 position - 1 */ private int getRealPosition(MyViewHolder holder) &#123; int position = holder.getLayoutPosition(); return mHeaderView == null ? position : position - 1; &#125; @Override public int getItemCount() &#123; //header 不为空，则 rv 的总 Count 需要 +1（把 Header 加上算一个 item） return mHeaderView == null ? mDatas.size() : mDatas.size() + 1; &#125; public class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView textView; public MyViewHolder(View itemView) &#123; super(itemView); if(itemView == mHeaderView)&#123; return; &#125; textView = (TextView) itemView.findViewById(R.id.tv_item); &#125; &#125; public void setOnItemClickListener(OnItemClickListener listener)&#123; mListener = listener; &#125; public interface OnItemClickListener&#123;//item 点击事件接口 void onItemClick(int position, String data); &#125;&#125; 以上是 Adapter 的代码，可见加了两个 TYPE 来区分 header 和 正常的数据 item。（我们也可以加更多的 Type 去实现更复杂的布局）在 onCreateViewHolder 里面判断 TYPE 如果是 header 则返回 headerView，否则加载正常的 item 布局。里面一些函数还有逻辑都加了注释说明了，这里就不详细说了。 MainActivity让我们回到 MainActivity，这里我们将初始化 Banner，并用 adapter.setmHeaderView 放进 Adapter 中。在使用 LayoutManager 设置一下 Rv 的布局，然后就基本完成了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344 private void initBanner()&#123; networkImage = Arrays.asList(images); mBanner.setPages(new CBViewHolderCreator&lt;NetWorkImageHolderView&gt;() &#123; @Override public NetWorkImageHolderView createHolder() &#123; return new NetWorkImageHolderView(); &#125; &#125;, networkImage) .setPageIndicatorAlign(ConvenientBanner.PageIndicatorAlign.ALIGN_PARENT_RIGHT) //设置指示器的方向（左、中、右） .setPageIndicator(new int[] &#123; R.drawable.indicator_gray, R.drawable.indicator_red &#125;)//设置指示器样式 .setOnItemClickListener(this)//点击事件 .setScrollDuration(1500);//滑动的时间 &#125; @Override public void onItemClick(int position) &#123;//Banner 点击事件 Toast.makeText(MainActivity.this, "Banner:"+position, Toast.LENGTH_SHORT).show(); &#125; public class NetWorkImageHolderView implements Holder&lt;String&gt;&#123; private ImageView imageView; @Override public View createView(Context context) &#123; View view = LayoutInflater.from(context).inflate(R.layout.rv_header_img, null); imageView = (ImageView) view.findViewById(R.id.iv_head); imageView.setScaleType(ImageView.ScaleType.CENTER_CROP); return view; &#125; @Override public void UpdateUI(Context context, int position, String data) &#123; //Glide.with(context).load(data.getImgUrl()).into(imageView); Log.d("imgUrl", "UpdateUI: "+data); Glide.with(context).load(data).placeholder(R.mipmap.ic_launcher_round).into(imageView); &#125; &#125;&#125; convenientBanner 的基本设置就是这样。通过 setPages 来配置，上面的配置都加了注释不详细说明，更多的配置样式可以查查。这里面的 NetWorkImageHolderView 是为了给 Banner 绑定 View。 mBanner 绑定的是 rv_header_banner 视图下的 banner 。而 NetWorkImageHolderView 里面的 view 绑定了 rv_header_img.里面的图片 ImageView 则是绑定了 R.id.iv_head 这个 img 控件。 总的来说，Banner 的视图 View 实际是 NetWorkImageHolderView 的 onCreateView 里面返回的。类同 Adapter 的使用 UpdateUI 这里用 Glide 加载了网络图片。Glide 不是这里的主角所以不说明了，用法也很简单。placeholder 是设置占位图。 以上就基本完成了 Banner 的配置。在 onResume 里面添加一句 mBanner.startTurning(3000) 就可以自动轮播了。 剩下的就是 Rv 的基本用法了。 还有需要的可以看一下我的源码。 这次demo的源码点这里]]></content>
      <categories>
        <category>Android 基础学习</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
        <tag>轮播图 Banner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 动画总结]]></title>
    <url>%2F2017%2F06%2F05%2FAndroid%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FAndroid%20%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Android 里面的动画可以分为两类，传统动画 和 3.0 以后出现的属性动画。 传统动画又分为两种：帧动画（Frame Animation）和补间动画（Tweened Animation） 传统动画帧动画（Frame Animation）帧动画就是像 GIF 的动图，一定时间内多张图片切换达到动画的视觉效果。 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/a_0" android:duration="100" /&gt; &lt;item android:drawable="@drawable/a_1" android:duration="100" /&gt; &lt;item android:drawable="@drawable/a_2" android:duration="100" /&gt;&lt;/animation-list&gt; 12345678protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_frame_animation); ImageView animationImg1 = (ImageView) findViewById(R.id.animation1); animationImg1.setImageResource(R.drawable.frame_anim1); AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable(); animationDrawable1.start(); &#125; 图片资源决定了这个动画，一定程度上也会因此占了资源的使用。 另外，有个常用的属性： android : oneshot=”false” ，就是只循环一次。 补间动画（Tweened Animation ）补间动画有四种属性： alpha：淡入淡出，透明度 translate：位移 scale：缩放大小 rotate： 旋转 补间动画一般使用 xml 来实现。举例子： alpha_anim.xml 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;alpha xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000" android:fromAlpha="1.0" android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:toAlpha="0.0" /&gt; scale.xm 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000" android:fromXScale="0.0" android:fromYScale="0.0" android:pivotX="50%" android:pivotY="50%" android:toXScale="1.0" android:toYScale="1.0"/&gt; Activity 中 123Animation animation = AnimationUtils.loadAnimation(mContext, R.anim.alpha_anim);img = (ImageView) findViewById(R.id.img);img.startAnimation(animation); 更多的时候，我们会将四个属性用 set 标签结合起来使用。 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:interpolator="@[package:]anim/interpolator_resource" android:shareInterpolator=["true" | "false"] &gt; &lt;alpha android:fromAlpha="float" android:toAlpha="float" /&gt; &lt;scale android:fromXScale="float" android:toXScale="float" android:fromYScale="float" android:toYScale="float" android:pivotX="float" android:pivotY="float" /&gt; &lt;translate android:fromXDelta="float" android:toXDelta="float" android:fromYDelta="float" android:toYDelta="float" /&gt; &lt;rotate android:fromDegrees="float" android:toDegrees="float" android:pivotX="float" android:pivotY="float" /&gt; &lt;set&gt; ... &lt;/set&gt;&lt;/set&gt; 其中稍稍一提的是 Interpolator ：主要是调变化的速率的。里面的属性有 AccelerateDecelerateInterpolator 在动画开始与介绍的地方速率改变比较慢，在中间的时候加速 AccelerateInterpolator 在动画开始的地方速率改变比较慢，然后开始加速 AnticipateInterpolator 开始的时候向后然后向前甩 AnticipateOvershootInterpolator 开始的时候向后然后向前甩一定值后返回最后的值 BounceInterpolator 动画结束的时候弹起 CycleInterpolator 动画循环播放特定的次数，速率改变沿着正弦曲线 DecelerateInterpolator 在动画开始的地方快然后慢 LinearInterpolator 以常量速率改变 OvershootInterpolator 向前甩一定值后再回到原来位置 像这样：android:interpolator=”@android:anim/accelerate_decelerate_interpolator” pivot: 决定了当前动画执行的参考位置 pivotX取值 含义 10 距离动画所在view自身左边缘10像素 10% 距离动画所在view自身左边缘 的距离是整个view宽度的10% 10%p 距离动画所在view父控件左边缘的距离是整个view宽度的10% 类同 pivotY 属性动画属性动画，是针对于对象属性的动画，补间动画的四个属性也在其中，因此，所有补间动画的内容都可以通过属性动画实现。 属性动画达到补间动画效果12345678910111213private void RotateAnimation() &#123; ObjectAnimator anim = ObjectAnimator.ofFloat(myView, "rotation", 0f, 360f); anim.setDuration(1000); anim.start(); &#125; private void AlpahAnimation() &#123; ObjectAnimator anim = ObjectAnimator.ofFloat(myView, "alpha", 1.0f, 0.8f, 0.6f, 0.4f, 0.2f, 0.0f); anim.setRepeatCount(-1);//重复执行次数。设置n，执行n+1次 anim.setRepeatMode(ObjectAnimator.REVERSE);//重复模式，重新从头执行。 anim.setDuration(2000); anim.start(); &#125; 如果是多组合的属性，也可以通过代码实现 1234567891011 ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(myView, "alpha", 1.0f, 0.5f, 0.8f, 1.0f); ObjectAnimator scaleXAnim = ObjectAnimator.ofFloat(myView, "scaleX", 0.0f, 1.0f); ObjectAnimator scaleYAnim = ObjectAnimator.ofFloat(myView, "scaleY", 0.0f, 2.0f); ObjectAnimator rotateAnim = ObjectAnimator.ofFloat(myView, "rotation", 0, 360); ObjectAnimator transXAnim = ObjectAnimator.ofFloat(myView, "translationX", 100, 400); ObjectAnimator transYAnim = ObjectAnimator.ofFloat(myView, "tranlsationY", 100, 750); AnimatorSet set = new AnimatorSet(); set.playTogether(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);//同时播放// set.playSequentially(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);//按顺序播放 set.setDuration(3000); set.start(); 上面使用的都是 ObjectAnimator ，他继承自 ValueAnimator ，而 valueAnimator 是整个属性动画机制最核心的类。 属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。 —— Android SDK API 文档 上图中我们可以看出可以通过 duration, startPropertyValue, endPropertyValue 等值，设置动画时长，初始值和结束值，然后通过 start（） 方法开启动画。 那么， TimeInterpolator 和 TypeEvaluator 又是干什么的呢？ TypeEvaluator ，意思为类型估值器。可以说是用来确定轨迹变化的。它的作用就是根据当前动画已经执行的时间占总时间的百分比来计算新的属性值。他只有一个函数，evaluate( float fraction, T startValue, T endValue ) 其中第一个参数为已执行时间占总时间的百分比。取值为[ 0.0 - 1.0 ].这个效果出来是线性的。比如平移，移动的速率是不变的。但是我们有时候需要非线性的效果，比如，小球模拟重力效果下坠之类。那就要 TimeInterPolator TimeInterpolator ，翻译的话是时间插值器。他就是通过 getInterpolator( float input ) 来改变上面的 fraction .重写这个函数里面对 input 进行一些换算（比如 input * input）,这样动画就会越来越快。]]></content>
      <categories>
        <category>Android 基础学习</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Broadcast Receiver 相关]]></title>
    <url>%2F2017%2F06%2F04%2FAndroid%20%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Broadcast%20Receiver%20%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[广播的常用场景开机启动服务，网络状态改变，电量变化，短信和来电通知通过接受系统的广播让应用程序做出相应处理。 使用注意系统或者应用发出广播的时候，将会扫描系统中所有的广播接收者，通过 action 匹配将广播发送给相应的接收者。收到广播后将会产生一个广播接收者的实例。执行 onReceiver() 这个方法。但是！这个实例的生命周期只有十秒。十秒内没有结束将会报错（ANR：Application Not Responding） 所以不要在 onReceiver() 中执行耗时操作，也不要在里面创建子线程处理业务（业务没处理完接收者就被回收了，子线程也会被回收掉）。 正确的应该是通过 in 调用 antivity 或者 service 处理业务。 广播的动态注册和静态注册有什么区别 静态注册，在 Manifest 文件里面进行注册，程序退出以后，Receiver 仍然可以接受到广播并且进行相应处理。 动态注册，在代码里面注册（onResume() 注册, onPause() 卸载），app 退出以后就无法再接受广播了。 发送广播的两种类型普通广播应用在需要通知各个广播接收者的情况下使用。比如开机。 sendBroadcast() 123Intent intent = new Intent("android.provider.Telephony.SMS_RECEIVER");intent.putExtra("data", "finch");//少量数据sendBroadcast(intent); 异步，消息传递效率较高，但是无法中断广播的传播。 有序广播广播会优先发给优先级 (android:priority) 高的 Receiver。并且能决定是否终止广播的继续传播。 特定拦截情境下使用。比如，黑名单短信，电话拦截。 sendOrderedBroadReceiver(intent, receiverPermission); 12345678910public void onReceiver(Context context, Intent intent)&#123; //获取上一个广播的bundle数据 Bundle bundle = getResultExtras(true);//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle bundle.putString("key", "777"); //将bundle数据放入广播中传给下一个广播接收者 setResultExtras(bundle); //终止广播传给下一个广播接收者 abortBroadcast();&#125; LocalBroadcastManager有时候基于数据安全考虑，我们想发送广播只有自己（本进程）能接收到，那么该如何去做呢？ 这就要提到 localBroadcastManager 了。 发送的广播只在自己 app 内传播，不会泄露发给其他 app，确保隐私数据不会泄露 比系统全局广播更加高效 和系统广播使用方式类似： 先通过LocalBroadcastManager lbm = LocalBroadcastManager.getInstance(this); 获取实例 然后通过函数 registerReceiver来注册监听器 12345678lbm.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO Handle the received local broadcast &#125; &#125;, new IntentFilter(LOCAL_ACTION)); lbm.sendBroadcast(new Intent(LOCAL_ACTION)); 使用广播来更新界面是否合适如果是比较频繁地更新界面，还是不要用广播了。 广播也会有延时的情况。sendBroadcast 之后，广播被 activityManagerService 放入队列，但并不会马上处理。 当处理到当前广播的时候，又会把这个广播分发给 ReceiverDispatcher 广播接受分发器，然后再把广播分发给 Receiver 所在的线程消息队列去处理。（UI 线程的 MessageQueue）。 整个过程从发送——ActivityManagerReceiver——ReceiverDispatcher 进行了两次 Binder 进程间通信，最后还要交到UI的消息队列，如果其中·有一个的消息的处理阻塞了UI，就会延迟 onReceiver 的执行。]]></content>
      <categories>
        <category>Android 面试集锦</category>
      </categories>
      <tags>
        <tag>四大组件</tag>
        <tag>面试</tag>
        <tag>Boradcast Reveiver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service 相关]]></title>
    <url>%2F2017%2F06%2F04%2FAndroid%20%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Service%20%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Service 的生命周期 onCreate 里面可以做耗时操作吗？不可以。service 也是在主线程里面运行的。耗时操作会阻塞UI。 如果需要耗时操作，你会怎么做？ service 中启动子线程处理。或者使用 IntentService ； Service 的两种启动方法有何区别 在 Context 中通过 public boolean bindService(Intent service, ServiceConnection conn, int flags) 方法来进行 Service 与 Context 的关联并启动， Service 的生命周期依附于 Context （不求同生，但是同死）,当启动方法销毁的时候会自动 unBind ,当发现所有的绑定都进行解绑之后才会销毁 Service。 通过 public ComponentName startService(Intent service) 方法启动一个 Service，生命周期与 Context 无关。只有当调用 stopSelf 或者其他组件调用 stopService 服务才会停止。 如何保证 Sercive 不被杀死首先完全不被杀死是不可能的，除非是系统级别的。能做的是杀死后采取措施让 Service 重新启动。 1. Service 设置成 START_STICKY kill 之后会被重启（等待时间 5秒 ），重传 Intent，保持与重启之前一样。 1234567&gt; @Override&gt; public int onStartCommand(Intent intent, int flags, int startId) &#123;&gt; flags = START_STICKY;&gt; return super.onStartCommand(intent, flags, startId);&gt; // return START_REDELIVER_INTENT;&gt; &#125;&gt; &gt; ​ 2. 提升 Service 优先级 在 Manifest 文件中对 intent-filter 设置属性 android:priority = &quot;1000&quot; ，其中，1000 是最高的优先级，数值越小优先级越低。（同样适用于广播） 【结论】目前看来，priority这个属性貌似只适用于broadcast，对于Service来说可能无效。 3. 提升 Service 进程优先级 Android 中进程是托管的，当系统进程空间紧张的时候，会依照优先级自动对进程回收。先销毁优先级低的。 前台进程 &gt; 可见进程 &gt; 服务进程 &gt; 后台进程 &gt; 内容供应节点(CONTENT_PROVIDER) &gt; 空进程 使用 startForeground 将 Service 放到前台状态 在极度低内存的情况下还是会 kill 掉，并且一定不会 restart 。 4. onDestory 方法里面重启 Service service + broadcast 方式，就是当 Service 走 onDestory 的时候，发送一条自定义广播，当收到广播时，重启 Service。 也可以直接在 onDestory 里面 startService 。 123456&gt; public void onDestroy() &#123; &gt; Intent localIntent = new Intent();&gt; localIntent.setClass(this, MyService.class); //销毁时重新启动Service&gt; this.startService(localIntent);&gt; &#125;&gt; &gt; ​ 在 setting 里面强制停止的话，app 进程就可能直接被干掉了，onDestory 都进不来。 5. 据说 手机QQ 放了一个像素在前台，顽强过小强。 IntentService 的使用场景与特点 IntentService 是 Service 的子类，是一个异步的，会自动停止的服务。很好滴解决了传统 Service 中处理完耗时操作之后忘记销毁 Service 的问题。内部还是用 handler 实现的。 优点： 不需要自己去 new Thread 不需要考虑什么时候关闭该 Service 使用场景：（！！！这里没懂，待验证！！！） onStartCommand中回调了onStart，onStart中通过mServiceHandler发送消息到该handler的handleMessage中去。最后handleMessage中回调onHandleIntent(intent)。]]></content>
      <categories>
        <category>Android 面试集锦</category>
      </categories>
      <tags>
        <tag>四大组件</tag>
        <tag>面试</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity 相关]]></title>
    <url>%2F2017%2F06%2F04%2FAndroid%20%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Activity%20%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Activity 基础Activity 是 Android 的四大组件之一。我们在使用的时候，往往都要在 Manifest 文件中给活动进行注册。 123456789&lt;activity android:name=".MainActivity" android:launchMode="singleTask"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;activity android:name=".SecondActivity"&gt;&lt;/activity&gt;&lt;acyivity android:name=".xxx"&gt;&lt;/activity&gt; 每个 Activity 都会存放到一个栈中（back stack），所有的 Activity 归属于栈管理。一般来说我们只有一个返回栈装载 Activity，每次启动新活动的时候都在栈顶新建一个Activity的实例并压入栈底。这也就是Activity启动的标准模式 (Standard). Activity 的启动模式可以在上面 Manifest 文件声明 Activity 那里看见，声明 Activity 的启动模式是 android:launchMode, android:launchMode = “standard | singleTop | singletTask | singleInstance” Standard 标准模式，也是默认的启动模式。假如有两个 Activity A，B。在标准模式情况下，先新建了 Activity A，A 入栈，点击跳转到 Activity B，新建 B 实例，压栈，然后 B 跳转到 A，A创建实例压栈。这样返回栈从底向上为 A1、B、A2. 不管这个 Activity 是否已经存在，Activity 的三回调都会执行（onCreate-&gt;onStart-&gt;onResume） SingleTop 栈顶模式，栈顶复用 。字面理解，就是在标准模式的情况下，如果新建的 Activity A 已经是栈顶，那么 A 将不会被创建，三回调不执行，同时 Activity 的 onNewIntent( )会被回调。 如果新的 Activity 不是栈顶，那么作用和 Standard 模式一样。 SingleTask 单栈模式，栈内复用 。创建 Activity 的时候，系统会判定栈内是否存在该 Activity 的实例，如果没有，创建实例压栈。 如果有，且在栈顶，不创建实例，直接复用。 如果有但是不在栈顶，会将该 Activity 上面的栈全部弹栈出去，让这个 Activity 调到了栈顶。 SingleInstance 单例模式。这里说的单例是全局单例。无论哪个 Task 中启动目标 Activity ，都只会创建一个 Activity 实例并却会用一个全新的栈来装载他。 ​ Activity 的生命周期Activity 最重要就是掌握生命周期。解释之前，先贴图： 这是经典的官方 Activity 生命周期图表。对于生命周期，我们一般分为一下几个周期： activity的完整生存期会在 onCreate() 调用和 onDestroy() 调用之间发生。 activity的可见生存期会在 onStart() 调用和 onStop() 调用之间发生。系统会在activity的整个生存期内多次调用 onStart() 和onStop()， 因为activity可能会在显示和隐藏之间不断地来回切换。 activity的前后台切换会在 onResume() 调用和 onPause() 之间发生。因为这个状态可能会经常发生转换，为了避免切换迟缓引起的用户等待，这两个方法中的代码应该相当地轻量化。 另外还有几个常见的我们会接触到的应用场景的周期： 启动 Activity:onCreate()—&gt;onStart()—&gt;onResume()，Activity 进入运行状态。 Activity 退居后台:当前Activity转到新的 Activity 界面或按 Home 键 回到主屏：onPause()—&gt;onStop()，进入停滞状态。 Activity 返回前台:onRestart()—&gt;onStart()—&gt;onResume()，再次回到运行状态。 Activity退居后台，且系统内存不足，系统会杀死这个后台状态的Activity（此时这个Activity引用仍然处在任务栈中，只是这个时候引用指向的对象已经为null），若再次回到这个Activity,则会走onCreate()–&gt;onStart()—&gt;onResume()(将重新走一次Activity的初始化生命周期) 锁屏：onPause()-&gt;onStop() 解锁：onStart()-&gt;onResume() ​ Activity A 跳转到 Activity B 后按下返回键 A 的生命周期变化Activity 的缓存方法 有两个 Activity a,b ，当从 A 进入 B 一段时间时候，可能会把 A 回收，这时候按下返回键，执行的就不是 Acticity 的 onRestart( )方法，而是 onCreate( )，A 被重新创建了一次，这时，A 中保存的临时数据和状态可能就丢失了。 这就是我们为什么要对 Activity 进行缓存。 onSaveInstanceState( Bundle bundle)这个方法会在 Activity 变得“容易”被销毁前调用，方法中一个 Bundle 参数可以存储键值对。以便回收后重建时数据恢复（ onCreate 或者 onRestoreInstanceState 里面恢复）。 先看一下一般的使用： 12345678910111213141516171819202122232425 @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //这里，当Acivity第一次被创建的时候为空 //所以我们需要判断一下 if( savedInstanceState != null )&#123; savedInstanceState.getString("key"); &#125;&#125;@Overrideprotected void onSaveInstanceState(Bundle outState)&#123; super.onSaveInstanceState(outState); outState.putString("key","Android");&#125; @Overrideprotected void onRestoreInstanceState(Bundle savedInstanceState) &#123; if(savedInstanceState!=null)&#123; //判断是否有以前的保存状态信息 savedInstanceState.get("Key"); &#125; super.onRestoreInstanceState(savedInstanceState);&#125; 上面我们有提到“容易”这个词，意思是当 Activity 还没有被销毁，但是有可能被销毁，存在可能性。换而言之，就是未经你允许时销毁了你的活动，那么系统救调用 onSaveInstanceState。 那么可能性有哪些？ 按下 HOME 键。 长按 HOME 键。（切换应用） 按下电源键。（熄屏） 从 Acitivty A 中启动一个新的 Activity。 切换屏幕方向。（不指定 configchange 属性） 注意： 不要在 onSaveInstanceState 里面去存储持久化数据。因为它本身带有不确定性，这个方法应该记录 Activity 的瞬间状态（UI状态）。当用户离开这个 Activity 应该在 onPause 里面存储持久化数据，例如存入数据库。 onSaveInstanceState 如果被调用一定会在 onStop 前被调用，但是不能保证它在 onPause 前还是后调用。 Activity 类的 onSaveInstanceState 默认实现会恢复这个 Activity 的状态，默认实现会为布局中的每个 View 调用相应的 onSaveInstanceState 方法，让每个 View 能保存自身的信息。 另外想要保存这个 View 的状态，需要在 XML 布局里面提供一个唯一的 ID 。如果是自定义控件，还需要 setSaveEnabled(true) ；]]></content>
      <categories>
        <category>Android 面试集锦</category>
      </categories>
      <tags>
        <tag>Activity</tag>
        <tag>四大组件</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[按下返回键 Activity 的生命周期变化]]></title>
    <url>%2F2017%2F05%2F31%2FAndroid%20%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F%E6%8C%89%E4%B8%8B%E8%BF%94%E5%9B%9E%E9%94%AE-Activity-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言： 因为之前被大佬问道这个问题，回来记录一下： 两个活动，从 Activity A 跳转到 Activity B 之后，按下返回键，Activity A 的生命周期变化？ 明显，这是一个生命周期问题。我回来之后，先创建了两个 Activity，并且重写了包括 onRestart（）方法在内的生命周期的方法，用 Log 打印输出。最后结果如下： 明显可见，Activity A 创建完毕（ onResume ）后，点击跳转，Activity A 就进入 onPause 状态，这时候就是 Activity B开始创建了，当 Activity B 创建完毕可见（ onResume ）后，Activity A 进入 onStop 状态。此时 A 不可见，B 可见。 点击返回键之后，B 进入 onPause 状态，而 A 调用 onStart 方法，走正常的周期流程。而 B 就进入销毁的程序。 过程如下： onCreate(A) -&gt; onStart(A) -&gt; onResume(A) -&gt; 点击跳转到 B -&gt; onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A) -&gt; 按下返回键 -&gt; onPause(B) -&gt; onRestart(A) -&gt; onStart(A) -&gt; onResume(A) -&gt; onStop(B) -&gt; onDestroy(B)]]></content>
      <categories>
        <category>Android 问题记录</category>
      </categories>
      <tags>
        <tag>Activity</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中的消息机制]]></title>
    <url>%2F2017%2F05%2F12%2FAndroid%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FAndroid%20%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言 涉及知识点： 消息机制：Handler、Looper 和 MessageQueue AsyncTask 基本使用 实现一个简单的 SimpleAsyncTask 消息机制Android 中的消息机制由三大部分组成：Handler、Looper 和 MessageQueue. Looper 就是创建一个 MessageQueue，然后进入一个死循环里面不断地读取 MessageQueue 里面的消息，Handler 就是消息的创建者，处理者。 由图我们可以看出，消息队列被封装在了 MessageQueue 中，通过 Looper 和线程 Thread 关联起来。而 Handler 又通过 Looper 关联，因而 Handler 最终和线程、线程的消息队列关联上来了。这也就是为什么我们常说更新 UI 的 Handler 必须要在主线程中创建，因为只有在主线程中创建，Handler 才能和主线程的消息队列关联上，这样 handleMessage 才会执行在 UI 线程，这时候更新 UI 才是线程安全的。 题外话：为什么常说只能在 UI 线程更新 UI ？ 子线程可以有好多个，但如果每个子线程都直接对UI元素进行操作，界面会混乱不堪，线程会面临安全问题，虽然可以通过加锁机制来解决线程的安全问题，但是加锁会降低运行效率， 所以主线程（UI线程）并没进行加锁限制多线程访问， 可能这就是“出于性能优化考虑”。 既然没有对多线程访问进行限制，而且子线程依然有进行UI操作的需求，那么该如何解决呢？ 所以Android规定只能在主线程中进行UI元素的更改，你们一帮菜鸡子线程如果还执意要来修改我管辖的用户界面 就必须先通知我（主线程），我来帮你们完成 :) ——知乎用户：大大大大头啊 创建自己的消息队列我们知道了基本的消息机制。但是，要注意的是，Android 中除了 UI 线程，创建的工作线程默认是没有消息循环和消息队列的。 在非主线程直接 new Handler(); 会报错 Uncaught handler: thread Thread-8 exiting due to uncaught exception java.lang.RuntimeException: Can&#39;t create handler inside thread that has not called Looper.prepare() 所以，如果想让自己创建的工作线程 有消息循环和消息队列，并具有消息处理机制，就需要在线程中先调用 Looper.prepare() 来创建消息队列，然后调用 Loop.loop() 进入消息循环 123456789101112131415public class MyloopThread extends Thread&#123; Handler mHandler; public void run()&#123; Loop.prepare(); mHandler = new Handler()&#123; public void handleMessage(Message msg)&#123; // process incoming message here &#125; &#125;; Loop.loop(); &#125;&#125; AsyncTask 基本使用我们往往使用 Thread 创建子线程进行耗时操作，但是由于不能在子线程更新 UI，一般就会使用 Handler 发送消息给 UI 线程然后再更新。这个操作起来有点麻烦，在多个任务同时执行的时候，不易于对线程进行精细控制。于是 AsyncTask 应运而生。 123&gt; public abstract class AsyncTask&lt; Param, Progress, Result &gt; ( ) &gt; //三个泛型类型： &lt; 参数类型，后台执行任务的进度类型，返回的结果类型 &gt; 如果不需要某个类型可以设置为 void&gt; 一个异步任务一般包含以下步骤： 实现一个简单的 AsyncTask下面我们来实现一个简单的 AsyncTask，类名为 SimpleAsyncTask。与 AsyncTask 类似，提供了三个函数：onPreExecute( )、 doInBackground( )、onPostExecute( )。泛型参数为了方便只有一个 doInBackgroud( ) 函数返回值类型的泛型参数。SimpleAsyncTask 执行起来和 AsyncTask 基本一样。首先是 onPreExecute 函数在任务运行之前执行，而且运行在 UI 线程之中。doInBackgroud 运行在后台执行耗时操作，并且将结果返回。onPostExecute 含有一个参数，这个参数就是 doInBaskgroud 的返回结果，onPostExecute 执行在 UI 线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public abstract class SimpleAsyncTask&lt;Result&gt; &#123; private static final HandlerThread HT = new HandlerThread("SimpleAsyncTask", Process.THREAD_PRIORITY_BACKGROUND); static &#123; HT.start(); &#125; final Handler mUIHandler = new Handler(Looper.getMainLooper()); final Handler mAsyncHandler = new Handler(HT.getLooper()); /** * @功能描述：onPreExecute 任务执行之前的初始化操作等 */ protected void onPreExecute()&#123;&#125; /** * 后台执行任务 * @return 返回执行结果 */ protected abstract Result doInBackground(); /** * 返回结果传递给执行在 UI 线程的 onPostExecute * @param result 执行结果 */ protected void onPostExecuted(Result result)&#123; &#125; public final SimpleAsyncTask&lt;Result&gt; excute () &#123; onPreExecute(); mAsyncHandler.post(new Runnable() &#123; @Override public void run() &#123; postResult(doInBackground()); &#125; &#125;); return this; &#125; private void postResult(final Result result)&#123; mUIHandler.post(new Runnable() &#123; @Override public void run() &#123; onPostExecuted(result); &#125; &#125;); &#125;&#125; 在 SimpleAsyncTask 里面首先创建了一个 HandlerThread（自带消息队列的 Thread），当线程启动之后就会构建它的消息队列，所以构建完成后，直接在静态代码块里面启动了该线程。然后创建了两个 Handler，分别关联 UI 线程和 HandlerThread 的子线程 mAsyncHandler。剩下三个函数已经解释过了，有需要的时候我们可以重写这三个方法。 execute 是执行的函数，里面先调用 onPreExecute，然后 doInBackground 函数被一个 Runnbale 包装通过 mAsyncTask 提交给了 HandlerThread 线程执行，当得到结果的时候又通过 mUIHandler 将结果提交到一个 Runnable 里面，这个 Runnbale 中执行了 onPostExecute。 下面是调用的示例代码： 12345678910111213141516171819202122232425new SimpleAsyncTask&lt;String&gt;() &#123; private void makeToast(String msg)&#123; Toast.makeText(getApplicationContext(), msg, Toast.LENGTH_SHORT).show(); &#125; @Override protected void onPreExecute() &#123; makeToast("onPreExecute"); &#125; @Override protected String doInBackground() &#123; try&#123; Thread.sleep(6000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return "doInBackground finish!"; &#125; @Override protected void onPostExecuted(String s) &#123; makeToast("onPostExecuted"+s); &#125;&#125;.excute(); 执行结果就是先 Toast：onPreExecute，延时 6 秒之后 Toast： onPostExecuted doInBackground finish！]]></content>
      <categories>
        <category>Android 基础学习</category>
      </categories>
      <tags>
        <tag>Android 基础知识</tag>
        <tag>AsyncTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下拉刷新的实现原理（Scroller 的使用）]]></title>
    <url>%2F2017%2F05%2F12%2FAndroid%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%88Scroller%20%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 涉及知识点： Scroller 使用 自定义 ViewGroup Measure 测量 View onTouchEvent 函数 初始化视图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public abstract class RefreshLayoutBase&lt;T extends View&gt; extends ViewGroup implements AbsListView.OnScrollListener&#123; protected Scroller mScroller;//滚动控制 protected View mHeaderView; protected View mFooterView; protected T mContentView; protected int mYOffset;//本次触摸 Y 轴坐标的偏移量 protected int mInitScrollY = 0;//最初的滚动位置，第一次布局时滚动header的高度的距离 protected int mLastY = 0;//最后一次触摸 Y 轴坐标 public static final int STATUS_IDLE = 0;//空闲状态 public static final int STATUS_PULL_TO_REFRESH = 1;//下拉或者上拉，但是没有达到可以刷新的状态 public static final int STATUS_RELEASE_TO_REFRESH = 2;//下拉或者上拉状态 public static final int STATUS_REFRESHING = 3;//刷新中 public static final int STATUS_LOADING = 4;//加载中 protected int mCurrentStatus = STATUS_IDLE; private ImageView mArrowImageView;//header中的箭头图标 private boolean isArrowUp;//箭头是否向上 private TextView mTipsTextView;//header 中的文本提示 private TextView mTimeTextView;//header 中的时间提示 private ProgressBar mProgressBar;//进度条 private int mScreenHeight;//屏幕高度 private int mHeaderHeight;// Header 高度 protected OnRefreshListener mOnRefreshListener;//下拉刷新监听 protected OnLoadListener mLoadListener;//加载更多回调 public RefreshLayoutBase(Context context) &#123; this(context, null); &#125; public RefreshLayoutBase(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public RefreshLayoutBase(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs); mScroller = new Scroller(context); mScreenHeight = context.getResources().getDisplayMetrics().heightPixels;//获取屏幕高度 mHeaderHeight = mScreenHeight / 4;//header 高度为屏幕高度四分之一 initLayout(context); &#125; protected final void initLayout(Context context)&#123; //headerView setupHeaderView(context); //设置内容视图 setupContentView(context); //设置布局参数 setDefaultContentLayoutParams(); //添加 contentView 布局 addView(mContentView); //设置底部视图 setupFooterView(context); &#125; /** * 设置布局参数 * 给 ContentView 宽高设置为 match_parent */ private void setDefaultContentLayoutParams() &#123; ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT); mContentView.setLayoutParams(params); &#125; /** * 初始化 footerView * @param context */ private void setupFooterView(Context context) &#123; mFooterView = LayoutInflater.from(context).inflate(R.layout.pull_to_refresh_footer, this, false); addView(mFooterView); &#125; /** * 内容视图 */ protected abstract void setupContentView(Context context); /** * 初始化 header * @param context */ private void setupHeaderView(Context context) &#123; mHeaderView = LayoutInflater.from(context).inflate(R.layout.pull_to_refresh_header, this, false); mHeaderView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, mHeaderHeight)); mHeaderView.setBackgroundColor(Color.RED); //header 高度为屏幕 1/4，但是，他只有 100px 的有效显示区域 mHeaderView.setPadding(0, mHeaderHeight - 100, 0, 0);//左上右下 addView(mHeaderView); mArrowImageView = (ImageView) mHeaderView.findViewById(R.id.pull_to_arrow_image); mTipsTextView = (TextView) mHeaderView.findViewById(R.id.pull_to_refresh_text); mTimeTextView = (TextView) mHeaderView.findViewById(R.id.pull_to_refresh_updated_at); mProgressBar = (ProgressBar) mHeaderView.findViewById(R.id.pull_to_refresh_progress); &#125; /**if isTop return true * 达到顶部继续下拉则拦截事件 * @return */ protected abstract boolean isTop(); /** * if isBottom return true * 达到底部触发加载更多 * @return */ protected abstract boolean isBottom();/***************************************************省略部分代码，详情见github****************************************************/&#125; 首先是一大堆的变量，都加了注释也没什么说的，后面用到再说吧。这里主要是 initLayout() 初始化了整个下拉刷新的布局，从上到下 headerView、contentView、footerView。其中 header 和 footer 都是从布局中加载的，固定好了的。但是 contentView 是抽象的，可变的，我们可以设置他是 ListView，RecyclerView，GridView 等，到时候继承即可。 另外还有两个函数 isTop() 和 isBottom()，因为我们在下拉刷新和上拉加载更多的时候，不同的内容视图判断到达底部顶部的代码是不一样的，所以把它也抽象了。 测量宽高MeasureSpec 的含义，组成接下来要做的就是测量。View的测量师自定义View中最重要的一步。在贴代码之前，有几个基本概念要搞清楚。看图： UNSPECIFIED 其实是开发人员按照自己的意愿调整大小，没有任何限制。但是这种情况很少见。 EXACTLY 往往对应 match_parent, AT_MOST 往往对应 warp_content getMeasureHeight() 和 getHeight() 区别简单地说 getMeasureHeight 可以测量到屏幕以外的布局， getHeight 测量到可视布局。 举个例子，一个上拉加载更多的组件，contentView 是100dp，footerView 是 50dp，但是 footerView（加载更多视图） 不可见。用getMeasureHeight 测量的高度就是 150dp。 123456789101112131415161718192021222324252627282930313233343536373839/** * 测量 viewGroup 宽高。宽度为用户定义。高度是 header, contentView, footer 三者之和 * @param widthMeasureSpec * @param heightMeasureSpec */@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int width = MeasureSpec.getSize(widthMeasureSpec); int childCount = getChildCount();//子视图个数 int finalHeight = 0;//最终的高度 for(int i = 0; i &lt; childCount; i++)&#123; View child = getChildAt(i); measureChild(child, widthMeasureSpec, heightMeasureSpec);//测量每个子视图 finalHeight += child.getMeasuredHeight(); &#125; //设置下拉刷新组件的尺寸(也就是这个 ViewGroup ) setMeasuredDimension(width, finalHeight); super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125;/** * 将 header、content、footer 从上到下布局 * 布局完成后通过 Scroller 滚动到 header 的底部 * 滑动距离为 header 高度 + 本视图 paddingtop，达到隐藏 header */@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childCount = getChildCount(); int top = getPaddingTop(); for(int i=0; i&lt;childCount; i++) &#123; View child = getChildAt(i); child.layout(0, top, child.getMeasuredWidth(), child.getMeasuredHeight() + top); top += child.getMeasuredHeight(); &#125; mInitScrollY = mHeaderView.getMeasuredHeight() + getPaddingTop(); scrollTo(0, mInitScrollY);&#125; 在onMeasure中测量了这个组件的自身大小和子视图的大小，并在onLayout中从上到下依次布局。 在 OnLayout 的最后通过 Scroller 将该 ViewGroup 滑动了 HeaderView 的高度使其不可见。 下拉刷新当用户向下按的时候，判断 ContentView 视图滑动到了顶部。此时又通过 Scroller 将该组件向下滚动，使得 HeaderView 可见。这些功能都需要让我们处理触摸事件。 1234567891011121314151617181920212223242526272829/** * 拦截触摸事件 * 在 ContentView 滑动到顶部，并且下拉的时候拦截 */ @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; //获取触摸事件类型 final int action = MotionEventCompat.getActionMasked(ev); //取消事件或者抬起事件直接返回false if(action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP)&#123; return false; &#125; switch(action) &#123; case MotionEvent.ACTION_DOWN: mLastY = (int) ev.getRawY(); break; case MotionEvent.ACTION_MOVE: mYOffset = (int) (ev.getRawY() - mLastY); //如果拉到了顶部，并且是下拉，拦截事件，转到 onTouchEvent 处理下拉刷新 if(isTop() &amp;&amp; mYOffset &gt; 0)&#123; return true; &#125; break; default: break; &#125; return false;//false 默认不拦截 &#125; onInterceptTouchEvent 是ViewGroup 中对触摸事件进行拦截的函数，返回 true时表示拦截。 例如：如果 mYOffset &gt; 0，那么代表用户是从上往下滑动。如果此时 ContentView 已经滑动到了顶部，那么第一个可见元素就是第一项，返回 true 就是将后续的时间进行拦截。此时，后续的 ACTION_MOVE 就会转到 onTouchEvent 函数进行处理。 12345678910111213141516171819202122232425262728293031323334/** * 在这里处理下拉刷新或者上拉加载更多 * @param event * @return */@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch(event.getAction())&#123; case MotionEvent.ACTION_MOVE: int currentY = (int) event.getRawY(); mYOffset = currentY - mLastY; if(mCurrentStatus != STATUS_LOADING)&#123; changeScrollY(mYOffset); &#125; rotateHeaderArrow(); changeTips(); mLastY = currentY; break; case MotionEvent.ACTION_UP: //下拉刷新具体操作 doRefresh(); break; default: break; &#125; return true;//返回 true，消费该事件&#125;protected void doRefresh() &#123; changeHeaderViewStaus(); if(mCurrentStatus == STATUS_REFRESHING &amp;&amp; mOnRefreshListener != null)&#123; mOnRefreshListener.onRefresh(); &#125;&#125; 在 onTouchEvent 函数中，判断他的事件类型。如果还是 MOVE，就计算 y 坐标的差值，在此处调用 changeScrollY 函数，在 y 轴上滚动该控件，另外还有改变箭头方向，文字提示等。如果是 ACTION_UP 手指抬起，说明松手了，就执行下拉刷新操作。当然执行的时候要判断 y坐标下拉的偏移值够不够。 123456789101112131415161718/** * 刷新结束时候调用，视图还原为基本状态 */public void refreshComplete()&#123; mScroller.startScroll(getScrollX(),getScrollY(),0,mInitScrollY - getScrollY()); mCurrentStatus = STATUS_IDLE; invalidate(); updateHeaderTimeStamp(); //100毫秒之后处理arrow和progress，免得太突兀 this.postDelayed(new Runnable() &#123; @Override public void run() &#123; mArrowImageView.setVisibility(View.VISIBLE); mProgressBar.setVisibility(View.GONE); &#125; &#125;,100);&#125;]]></content>
      <categories>
        <category>Android 自定义控件</category>
      </categories>
      <tags>
        <tag>Android 自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android项目结构]]></title>
    <url>%2F2017%2F05%2F03%2FAndroid%20%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%2Fandroid%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[规范1.AS 规范 尽量使用最新版的IDE进行开发； 编码格式统一为UTF-8； 编辑完.java、 .xml等文件后一定要格式化（基本格式方面使用 AS 默认模板即可）； 删除多余的import，减少警告出现，可利用AS的Optimize Imports(Settings → Keymap → Optimize Imports)快捷键； 2.命名规范包名全部小写，连续的单词只是简单地连接起来，不使用下划线，采用反域名命名规则，全部使用小写字母。 一级包名是顶级域名，通常为com,edu,gov,net,org等，二级包名为公司名，三级包名根据应用进行命名，后面就是对包名的划分了，关于包名的划分，推荐使用按功能分。比如像这样： 或者参考谷歌 I/O 2015 的代码结构： 类名名词，采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的， 比如HTML, URL，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。 类 描述 例如 Activity 类 Activity为后缀标识 欢迎页面类WelcomeActivity Adapter类 Adapter 为后缀标识 新闻详情适配器 NewDetailAdapter 解析类 Parser为后缀标识 首页解析类HomePosterParser 工具方法类 Utils或Manager为后缀标识（与系统或第三方的Utils区分）或功能+Utils 线程池管理类：ThreadPoolManager日志工具类：LogUtils（Logger也可）打印工具类：PrinterUtils 数据库类 以DBHelper后缀标识 新闻数据库：NewDBHelper Service类 以Service为后缀标识 时间服务TimeService BroadcastReceiver类 以Receiver为后缀标识 推送接收JPushReceiver ContentProvider类 以Provider为后缀标识 ShareProvider 自定义的共享基础类 以Base开头 BaseActivity,BaseFragment 接口（interface）：命名规则与类一样采用大驼峰命名法，多以able或ible结尾，如： interface Runnable、interface Accessible。 注意：如果项目采用MVP，所有Model、View、Presenter的接口都以I为前缀，不加后缀，其他的接口采用上述命名规则。 方法 方法 说明 initXX() 初始化相关方法,使用init为前缀标识，如初始化布局initView() isXX() checkXX() 方法返回值为boolean型的请使用is或check为前缀标识 getXX() 返回某个值的方法，使用get为前缀标识 setXX() 设置某个属性值 handleXX()/processXX() 对数据进行处理的方法 displayXX()/showXX() 弹出提示框和提示信息，使用display/show为前缀标识 updateXX() 更新数据 saveXX() 保存数据 resetXX() 重置数据 clearXX() 清除数据 removeXX() 移除数据或者视图等，如removeView(); drawXX() 绘制数据或效果相关的，使用draw前缀标识 3.资源文件3.1.1 contentView命名必须以全部单词小写，单词间以下划线分割，使用名词或名词词组。 所有Activity或Fragment的contentView必须与其类名对应，对应规则为：将所有字母都转为小写，将类型和功能调换（也就是后缀变前缀）。 例如：activity_main.xml 3.1.5 包含项命名规则：模块_(位置)描述.xml 例如：activity_main_head.xml、activity_main_bottom.xml 注意：通用的包含项命名采用：项目名称缩写_描述.xml 例如：xxxx_title.xml 3.2 资源文件（图片drawable文件夹下）全部小写，采用下划线命名法，加前缀区分 命名模式：可加后缀 _small 表示小图， _big 表示大图，逻辑名称可由多个单词加下划线组成，采用以下规则： 用途模块名逻辑名称 用途模块名颜色 用途_逻辑名称 用途_颜色 说明：用途也指控件类型（具体见附录UI控件缩写表） http://www.jianshu.com/p/419f5357357d#ui%E6%8E%A7%E4%BB%B6%E7%BC%A9%E5%86%99%E8%A1%A8 例如： 名称 说明 btn_main_home.png 按键用途模块名逻辑名称 divider_maket_white.png 分割线用途模块名颜色 ic_edit.png 图标用途_逻辑名称 bg_main.png 背景用途_逻辑名称 btn_red.png 红色按键用途_颜色 btn_red_big.png 红色大按键用途_颜色 ic_head_small.png 小头像用途_逻辑名称 bg_input.png 输入框背景用途_逻辑名称 divider_white.png 白色分割线用途_颜色 bg_main_head 主模块头部背景图片用途模块名逻辑名称 def_search_cell 默认搜索界面单元图片用途模块名逻辑名称 ic_more_help 更多帮助图标用途_逻辑名称 divider_list_line 列表分割线用途_逻辑名称 selector_search_ok 搜索界面确认选择器用途模块名逻辑名称 shape_music_ring 音乐界面环形形状用途模块名逻辑名称 如果有多种形态，如按钮选择器：btn_xx.xml(selector) 名称 说明 btn_xx 按钮图片使用btn_整体效果（selector） btn_xx_normal 按钮图片使用btn_正常情况效果 btn_xx_pressed 按钮图片使用btn_点击时候效果 btn_xx_focused state_focused聚焦效果 btn_xx_disabled state_enabled (false)不可用效果 btn_xx_checked state_checked选中效果 btn_xx_selected state_selected选中效果 btn_xx_hovered state_hovered悬停效果 btn_xx_checkable state_checkable可选效果 btn_xx_activated state_activated激活的 btn_xx_windowfocused state_window_focused 注意：使用AndroidStudio的插件SelectorChapek可以快速生成selector，前提是命名要规范。 3.3 动画文件（anim文件夹下）全部小写，采用下划线命名法，加前缀区分。 具体动画采用以下规则：模块名_逻辑名称。 例如：refresh_progress.xml、market_cart_add.xml、market_cart_remove.xml。 普通的tween动画采用如下表格中的命名方式：动画类型_方向 名称 说明 fade_in 淡入 fade_out 淡出 push_down_in 从下方推入 push_down_out 从下方推出 push_left 推向左方 slide_in_from_top 从头部滑动进入 zoom_enter 变形进入 slide_in 滑动进入 shrink_to_middle 中间缩小]]></content>
      <categories>
        <category>Android 项目基础</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>规范</tag>
      </tags>
  </entry>
</search>