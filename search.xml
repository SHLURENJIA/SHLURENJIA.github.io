<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2017%2F05%2F12%2FAndroid%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%88Scroller%20%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[下拉刷新（Scroller 的使用） title: 下拉刷新的实现原理（Scroller 的使用） categories: Android 自定义控件 tags: Android 自定义控件 前言 涉及知识点： Scroller 使用 自定义 ViewGroup Measure 测量 View onTouchEvent 函数 初始化视图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public abstract class RefreshLayoutBase&lt;T extends View&gt; extends ViewGroup implements AbsListView.OnScrollListener&#123; protected Scroller mScroller;//滚动控制 protected View mHeaderView; protected View mFooterView; protected T mContentView; protected int mYOffset;//本次触摸 Y 轴坐标的偏移量 protected int mInitScrollY = 0;//最初的滚动位置，第一次布局时滚动header的高度的距离 protected int mLastY = 0;//最后一次触摸 Y 轴坐标 public static final int STATUS_IDLE = 0;//空闲状态 public static final int STATUS_PULL_TO_REFRESH = 1;//下拉或者上拉，但是没有达到可以刷新的状态 public static final int STATUS_RELEASE_TO_REFRESH = 2;//下拉或者上拉状态 public static final int STATUS_REFRESHING = 3;//刷新中 public static final int STATUS_LOADING = 4;//加载中 protected int mCurrentStatus = STATUS_IDLE; private ImageView mArrowImageView;//header中的箭头图标 private boolean isArrowUp;//箭头是否向上 private TextView mTipsTextView;//header 中的文本提示 private TextView mTimeTextView;//header 中的时间提示 private ProgressBar mProgressBar;//进度条 private int mScreenHeight;//屏幕高度 private int mHeaderHeight;// Header 高度 protected OnRefreshListener mOnRefreshListener;//下拉刷新监听 protected OnLoadListener mLoadListener;//加载更多回调 public RefreshLayoutBase(Context context) &#123; this(context, null); &#125; public RefreshLayoutBase(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public RefreshLayoutBase(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs); mScroller = new Scroller(context); mScreenHeight = context.getResources().getDisplayMetrics().heightPixels;//获取屏幕高度 mHeaderHeight = mScreenHeight / 4;//header 高度为屏幕高度四分之一 initLayout(context); &#125; protected final void initLayout(Context context)&#123; //headerView setupHeaderView(context); //设置内容视图 setupContentView(context); //设置布局参数 setDefaultContentLayoutParams(); //添加 contentView 布局 addView(mContentView); //设置底部视图 setupFooterView(context); &#125; /** * 设置布局参数 * 给 ContentView 宽高设置为 match_parent */ private void setDefaultContentLayoutParams() &#123; ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT); mContentView.setLayoutParams(params); &#125; /** * 初始化 footerView * @param context */ private void setupFooterView(Context context) &#123; mFooterView = LayoutInflater.from(context).inflate(R.layout.pull_to_refresh_footer, this, false); addView(mFooterView); &#125; /** * 内容视图 */ protected abstract void setupContentView(Context context); /** * 初始化 header * @param context */ private void setupHeaderView(Context context) &#123; mHeaderView = LayoutInflater.from(context).inflate(R.layout.pull_to_refresh_header, this, false); mHeaderView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, mHeaderHeight)); mHeaderView.setBackgroundColor(Color.RED); //header 高度为屏幕 1/4，但是，他只有 100px 的有效显示区域 mHeaderView.setPadding(0, mHeaderHeight - 100, 0, 0);//左上右下 addView(mHeaderView); mArrowImageView = (ImageView) mHeaderView.findViewById(R.id.pull_to_arrow_image); mTipsTextView = (TextView) mHeaderView.findViewById(R.id.pull_to_refresh_text); mTimeTextView = (TextView) mHeaderView.findViewById(R.id.pull_to_refresh_updated_at); mProgressBar = (ProgressBar) mHeaderView.findViewById(R.id.pull_to_refresh_progress); &#125; /**if isTop return true * 达到顶部继续下拉则拦截事件 * @return */ protected abstract boolean isTop(); /** * if isBottom return true * 达到底部触发加载更多 * @return */ protected abstract boolean isBottom();/***************************************************省略部分代码，详情见github****************************************************/&#125; 首先是一大堆的变量，都加了注释也没什么说的，后面用到再说吧。这里主要是 initLayout() 初始化了整个下拉刷新的布局，从上到下 headerView、contentView、footerView。其中 header 和 footer 都是从布局中加载的，固定好了的。但是 contentView 是抽象的，可变的，我们可以设置他是 ListView，RecyclerView，GridView 等，到时候继承即可。 另外还有两个函数 isTop() 和 isBottom()，因为我们在下拉刷新和上拉加载更多的时候，不同的内容视图判断到达底部顶部的代码是不一样的，所以把它也抽象了。 测量宽高MeasureSpec 的含义，组成接下来要做的就是测量。View的测量师自定义View中最重要的一步。在贴代码之前，有几个基本概念要搞清楚。看图： UNSPECIFIED 其实是开发人员按照自己的意愿调整大小，没有任何限制。但是这种情况很少见。 EXACTLY 往往对应 match_parent, AT_MOST 往往对应 warp_content getMeasureHeight() 和 getHeight() 区别简单地说 getMeasureHeight 可以测量到屏幕以外的布局， getHeight 测量到可视布局。 举个例子，一个上拉加载更多的组件，contentView 是100dp，footerView 是 50dp，但是 footerView（加载更多视图） 不可见。用getMeasureHeight 测量的高度就是 150dp。 123456789101112131415161718192021222324252627282930313233343536373839/** * 测量 viewGroup 宽高。宽度为用户定义。高度是 header, contentView, footer 三者之和 * @param widthMeasureSpec * @param heightMeasureSpec */@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int width = MeasureSpec.getSize(widthMeasureSpec); int childCount = getChildCount();//子视图个数 int finalHeight = 0;//最终的高度 for(int i = 0; i &lt; childCount; i++)&#123; View child = getChildAt(i); measureChild(child, widthMeasureSpec, heightMeasureSpec);//测量每个子视图 finalHeight += child.getMeasuredHeight(); &#125; //设置下拉刷新组件的尺寸(也就是这个 ViewGroup ) setMeasuredDimension(width, finalHeight); super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125;/** * 将 header、content、footer 从上到下布局 * 布局完成后通过 Scroller 滚动到 header 的底部 * 滑动距离为 header 高度 + 本视图 paddingtop，达到隐藏 header */@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childCount = getChildCount(); int top = getPaddingTop(); for(int i=0; i&lt;childCount; i++) &#123; View child = getChildAt(i); child.layout(0, top, child.getMeasuredWidth(), child.getMeasuredHeight() + top); top += child.getMeasuredHeight(); &#125; mInitScrollY = mHeaderView.getMeasuredHeight() + getPaddingTop(); scrollTo(0, mInitScrollY);&#125; 在onMeasure中测量了这个组件的自身大小和子视图的大小，并在onLayout中从上到下依次布局。 在 OnLayout 的最后通过 Scroller 将该 ViewGroup 滑动了 HeaderView 的高度使其不可见。 下拉刷新当用户向下按的时候，判断 ContentView 视图滑动到了顶部。此时又通过 Scroller 将该组件向下滚动，使得 HeaderView 可见。这些功能都需要让我们处理触摸事件。 1234567891011121314151617181920212223242526272829/** * 拦截触摸事件 * 在 ContentView 滑动到顶部，并且下拉的时候拦截 */ @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; //获取触摸事件类型 final int action = MotionEventCompat.getActionMasked(ev); //取消事件或者抬起事件直接返回false if(action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP)&#123; return false; &#125; switch(action) &#123; case MotionEvent.ACTION_DOWN: mLastY = (int) ev.getRawY(); break; case MotionEvent.ACTION_MOVE: mYOffset = (int) (ev.getRawY() - mLastY); //如果拉到了顶部，并且是下拉，拦截事件，转到 onTouchEvent 处理下拉刷新 if(isTop() &amp;&amp; mYOffset &gt; 0)&#123; return true; &#125; break; default: break; &#125; return false;//false 默认不拦截 &#125; onInterceptTouchEvent 是ViewGroup 中对触摸事件进行拦截的函数，返回 true时表示拦截。 例如：如果 mYOffset &gt; 0，那么代表用户是从上往下滑动。如果此时 ContentView 已经滑动到了顶部，那么第一个可见元素就是第一项，返回 true 就是将后续的时间进行拦截。此时，后续的 ACTION_MOVE 就会转到 onTouchEvent 函数进行处理。 12345678910111213141516171819202122232425262728293031323334/** * 在这里处理下拉刷新或者上拉加载更多 * @param event * @return */@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch(event.getAction())&#123; case MotionEvent.ACTION_MOVE: int currentY = (int) event.getRawY(); mYOffset = currentY - mLastY; if(mCurrentStatus != STATUS_LOADING)&#123; changeScrollY(mYOffset); &#125; rotateHeaderArrow(); changeTips(); mLastY = currentY; break; case MotionEvent.ACTION_UP: //下拉刷新具体操作 doRefresh(); break; default: break; &#125; return true;//返回 true，消费该事件&#125;protected void doRefresh() &#123; changeHeaderViewStaus(); if(mCurrentStatus == STATUS_REFRESHING &amp;&amp; mOnRefreshListener != null)&#123; mOnRefreshListener.onRefresh(); &#125;&#125; 在 onTouchEvent 函数中，判断他的事件类型。如果还是 MOVE，就计算 y 坐标的差值，在此处调用 changeScrollY 函数，在 y 轴上滚动该控件，另外还有改变箭头方向，文字提示等。如果是 ACTION_UP 手指抬起，说明松手了，就执行下拉刷新操作。当然执行的时候要判断 y坐标下拉的偏移值够不够。 123456789101112131415161718/** * 刷新结束时候调用，视图还原为基本状态 */public void refreshComplete()&#123; mScroller.startScroll(getScrollX(),getScrollY(),0,mInitScrollY - getScrollY()); mCurrentStatus = STATUS_IDLE; invalidate(); updateHeaderTimeStamp(); //100毫秒之后处理arrow和progress，免得太突兀 this.postDelayed(new Runnable() &#123; @Override public void run() &#123; mArrowImageView.setVisibility(View.VISIBLE); mProgressBar.setVisibility(View.GONE); &#125; &#125;,100);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[android项目结构]]></title>
    <url>%2F2017%2F05%2F03%2FAndroid%20%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%2Fandroid%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1.项目结构 现在的MVP模式越来越流行。就默认采用了。如果项目比较小的话： app——Application Activity Fragment Presenter等的顶级父类 config——API,常量表等 model——数据层 bean——数据模型 presenter——MVP的P view——MVP的V utils——工具类集合 widget——各个可复用View集合 如果项目比较大，上面的方式一定会造成presenter和view里近百个文件。看瞎眼系列。推荐下列方式： app config model bean module——将界面层以功能模块分配包。 launch main account news music …… utils widget]]></content>
      <categories>
        <category>Android 项目基础</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>